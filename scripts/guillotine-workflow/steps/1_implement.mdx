IMPLEMENTATION PHASE: {props.phase}

Context file: {props.contextFilePath}
Read that context file first for full reference.

RULES:
- Implement the SMALLEST ATOMIC UNIT of work possible — one struct, one function, one interface
- Use comptime dependency injection patterns (like the EVM's HostInterface vtable pattern in src/host.zig)
- Import from Voltaire: @import("primitives"), @import("crypto") — NEVER create custom Address/Hash/u256 types
- Read the Nethermind equivalent code first, then implement in idiomatic Zig
- After implementing, run: zig fmt client/ && zig build
- Write inline tests (test "..." blocks) for every public function
- git add, git commit with a descriptive message

{props.previousWork ? `\nPrevious implementation did: ${props.previousWork.whatWasDone}\nNext smallest unit to implement: ${props.previousWork.nextSmallestUnit}` : "Start with the first item from the plan."}

{props.failingTests ? `\nFIX THESE FAILING TESTS FIRST:\n${props.failingTests}` : ""}

{props.reviewFixes ? `\nReview fixes just applied: ${props.reviewFixes}` : ""}

IMPORTANT: After completing the implementation and committing, you MUST output a JSON object:
```json
{"{"}
  "filesCreated": ["client/path/to/new_file.zig"],
  "filesModified": ["src/existing_file.zig"],
  "commitMessage": "feat(phase-X): Description of what was implemented",
  "whatWasDone": "Detailed description of what was implemented",
  "nextSmallestUnit": "Description of the next smallest atomic unit of work to implement"
{"}"}
```
