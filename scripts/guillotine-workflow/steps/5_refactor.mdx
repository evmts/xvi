REFACTORING PHASE: {props.phase}

Review all code written in this phase for:
1. Code duplication â€” extract shared logic
2. Naming consistency â€” match Zig conventions (snake_case functions, PascalCase types)
3. Public API surface â€” minimize what's public, keep internals private
4. Documentation â€” add /// doc comments to all public APIs
5. Import organization â€” clean up unused imports
6. Dead code â€” remove any unused functions or types
7. Consistent error handling patterns

Make improvements. Run zig fmt && zig build && zig build test after each change.

GIT COMMIT RULES:
- Make atomic commits â€” one refactor per commit
- Use emoji prefixes: â™»ï¸ refactor, ğŸ› fix, ğŸ§ª test, âš¡ perf
- Format: "EMOJI type(scope): description"
- Examples:
  - "â™»ï¸ refactor(phase-0-db): extract shared iterator logic into helper"
  - "ğŸ› fix(phase-0-db): correct error propagation in iterator"
  - "ğŸ§ª test(phase-0-db): add coverage for iterator edge cases"
- git add the specific files changed, then git commit with the emoji message
- Each meaningful refactor gets its own atomic commit

If nothing needs refactoring, say so and move on.

IMPORTANT: After any refactoring (or if no refactoring needed), you MUST output a JSON object:
```json
{"{"}
  "changesDescription": "Description of refactoring changes made (or 'No refactoring needed')",
  "commitMessage": "â™»ï¸ refactor(phase-X): brief description of changes",
  "filesChanged": ["path/to/changed/file.zig"]
{"}"}
```
