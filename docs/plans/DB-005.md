# DB-005: Add multi-get batch read API to Database vtable

## Overview

Add an optional `multi_get` vtable slot to `Database.VTable` in `adapter.zig`, following the exact same `?*const fn` pattern used by `write_batch` and `merge`. This enables efficient batch key lookups that map to RocksDB's `MultiGet` API for significant performance gains during snapshot reads and state prefetching.

**Design choice**: Caller-provided output buffer (no hidden allocations). The caller passes both `keys` and a `results` buffer of the same length. The backend fills `results[i]` with the value for `keys[i]` (null if not found). This is idiomatic Zig — no allocator needed in the vtable call.

**Fallback behavior**: When `multi_get` is null on the vtable, the convenience method falls back to sequential `get()` calls (same pattern as `write_batch` falling back to sequential puts).

## Step-by-step Implementation Order

### Step 1: Add `multi_get` optional vtable slot to `Database.VTable`

**File**: `client/db/adapter.zig`

Add after the `merge` field in `VTable`:

```zig
/// Retrieve multiple values in a single batch operation.
///
/// Backends that support native multi-key reads (e.g., RocksDB MultiGet)
/// should implement this for batched I/O efficiency.
/// If `null`, `Database.multi_get()` falls back to sequential `get()` calls.
///
/// `keys` and `results` must have the same length. The backend fills
/// `results[i]` with the value for `keys[i]` (null if not found).
/// Caller owns both slices and must release each non-null DbValue.
///
/// Mirrors Nethermind's `IDb.this[byte[][] keys]` indexer.
multi_get: ?*const fn (ptr: *anyopaque, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void = null,
```

**Tests to write (in adapter.zig)**:
- `"Database supports_multi_get reports false when absent"` — MockDb has no multi_get
- `"Database supports_multi_get reports true when present"` — Mock with multi_get set

### Step 2: Add `multi_get()`, `multi_get_with_flags()`, and `supports_multi_get()` convenience methods to `Database`

**File**: `client/db/adapter.zig`

Add to the `Database` struct after `merge_with_flags`:

```zig
/// Returns true if the backend provides a native `multi_get` implementation.
pub fn supports_multi_get(self: Database) bool {
    return self.vtable.multi_get != null;
}

/// Retrieve multiple values in a single batch with default read flags.
///
/// If the backend supports native multi-get, dispatches directly.
/// Otherwise, falls back to sequential `get()` calls.
///
/// `keys.len` must equal `results.len`. On return, `results[i]` is
/// the value for `keys[i]` (null if not found). Caller must release
/// each non-null DbValue.
pub fn multi_get(self: Database, keys: []const []const u8, results: []?DbValue) Error!void {
    return self.multi_get_with_flags(keys, results, ReadFlags.none);
}

/// Retrieve multiple values in a single batch with explicit read flags.
pub fn multi_get_with_flags(self: Database, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void {
    if (self.vtable.multi_get) |mg_fn| {
        return mg_fn(self.ptr, keys, results, flags);
    }
    // Sequential fallback — same pattern as WriteBatch sequential fallback.
    for (keys, 0..) |key, i| {
        results[i] = try self.get_with_flags(key, flags);
    }
}
```

**Tests to write (in adapter.zig)**:
- `"Database multi_get sequential fallback returns correct results"` — use TrackingDb-style mock, verify each result
- `"Database multi_get_with_flags sequential fallback works"` — verify flags are forwarded
- `"Database multi_get dispatches to vtable when present"` — mock with multi_get set, verify dispatch
- `"Database multi_get with empty keys slice is no-op"` — edge case

### Step 3: Update `Database.init()` comptime helper to handle `multi_get`

**File**: `client/db/adapter.zig`

Add `multi_get` to the `fns` struct parameter of `Database.init()`:

```zig
multi_get: ?*const fn (self: *T, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void = null,
```

Add wrapper function in the Wrapper struct:

```zig
fn multi_get_impl(raw: *anyopaque, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void {
    const typed: *T = @ptrCast(@alignCast(raw));
    const mg_fn = fns.multi_get orelse unreachable;
    return mg_fn(typed, keys, results, flags);
}
```

Add to vtable construction:

```zig
.multi_get = if (fns.multi_get == null) null else multi_get_impl,
```

**Tests to write (in adapter.zig)**:
- `"Database.init with multi_get generates correct dispatch"` — verify typed dispatch through comptime wrapper
- `"Database.init without multi_get defaults to null"` — verify existing tests still pass (multi_get omitted)

### Step 4: Update `test_vtable()` helper to accept optional `multi_get`

**File**: `client/db/adapter.zig`

Add to the `test_vtable` overrides struct:

```zig
multi_get: ?*const fn (*anyopaque, []const []const u8, []?DbValue, ReadFlags) Error!void = null,
```

Add to the returned VTable:

```zig
.multi_get = overrides.multi_get,
```

### Step 5: Implement `multi_get` in `MemoryDatabase`

**File**: `client/db/memory.zig`

Add a direct method and vtable impl:

```zig
/// Retrieve multiple values in a single batch (sequential lookup).
///
/// Mirrors Nethermind's `MemDb.this[byte[][] keys]` which does
/// `keys.Select(k => new KeyValuePair(k, _db.GetValueOrDefault(k))).ToArray()`.
/// Increments `reads_count` by `keys.len`.
pub fn multi_get(self: *MemoryDatabase, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) void {
    for (keys, 0..) |key, i| {
        results[i] = self.get_with_flags(key, flags);
    }
}

fn multi_get_impl(self: *MemoryDatabase, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void {
    self.multi_get(keys, results, flags);
}
```

Update the `database()` method to pass `.multi_get = multi_get_impl`.

**Tests to write (in memory.zig)**:
- `"MemoryDatabase: multi_get returns found and missing keys"` — mix of present and absent keys
- `"MemoryDatabase: multi_get with empty keys slice"` — edge case
- `"MemoryDatabase: multi_get increments reads_count"` — verify count = keys.len
- `"MemoryDatabase: multi_get via vtable interface"` — dispatch through Database vtable

### Step 6: Implement `multi_get` in `NullDb`

**File**: `client/db/null.zig`

```zig
fn multi_get_impl(_: *NullDb, _: []const []const u8, results: []?DbValue, _: ReadFlags) Error!void {
    // Null database: no data stored, all results are null.
    for (results) |*r| {
        r.* = null;
    }
}
```

Update `database()` to pass `.multi_get = multi_get_impl`.

**Tests to write (in null.zig)**:
- `"NullDb: multi_get returns all nulls"` — verify all results are null
- `"NullDb: multi_get with empty keys slice"` — edge case

### Step 7: Implement `multi_get` in `ReadOnlyDb`

**File**: `client/db/read_only.zig`

The overlay merge pattern: check overlay first, then wrapped DB.

```zig
fn multi_get_impl(self: *ReadOnlyDb, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void {
    if (self.overlay) |ov| {
        // Check overlay for each key first.
        for (keys, 0..) |key, i| {
            if (ov.get_with_flags(key, flags)) |val| {
                results[i] = val;
            } else {
                // Not in overlay — fall back to wrapped.
                results[i] = try self.wrapped.get_with_flags(key, flags);
            }
        }
    } else {
        // No overlay — delegate entirely to wrapped.
        // If wrapped supports multi_get, use it; otherwise sequential fallback via Database.multi_get_with_flags.
        try self.wrapped.multi_get_with_flags(keys, results, flags);
    }
}
```

Update `database()` to pass `.multi_get = multi_get_impl`.

**Tests to write (in read_only.zig)**:
- `"ReadOnlyDb: multi_get delegates to wrapped (no overlay)"` — strict read-only
- `"ReadOnlyDb: multi_get overlay takes precedence over wrapped"` — overlay wins
- `"ReadOnlyDb: multi_get with mix of overlay and wrapped keys"` — some in overlay, some in wrapped, some missing
- `"ReadOnlyDb: multi_get after clear_temp_changes falls back to wrapped"` — verify overlay cleared

### Step 8: Implement `multi_get` stub in `RocksDatabase`

**File**: `client/db/rocksdb.zig`

```zig
fn multi_get_impl(_: *RocksDatabase, _: []const []const u8, _: []?DbValue, _: ReadFlags) Error!void {
    // Stub: RocksDB backend not implemented yet.
    return error.StorageError;
}
```

Update `database()` to pass `.multi_get = multi_get_impl`.

**Tests to write (in rocksdb.zig)**:
- `"RocksDatabase: multi_get returns StorageError (unimplemented stub)"` — consistency with other stubs

### Step 9: Update `ColumnsDb` if needed

**File**: `client/db/columns.zig`

No changes needed to `ColumnsDb(T)` itself — it delegates to `Database` handles, and `multi_get` is already available on the `Database` interface from Step 2. The column-level multi_get is accessed via `cdb.getColumnDb(.column).multi_get(keys, results)`.

If a cross-column multi_get is desired (different keys per column in one batch), that would be a separate ticket. For now, per-column multi_get is sufficient.

### Step 10: Verify all tests pass

```bash
zig build test    # Full unit test suite
zig fmt client/db/  # Format check
```

## Files to Create

None — all changes are modifications to existing files.

## Files to Modify

| File | Changes |
|------|---------|
| `client/db/adapter.zig` | Add `multi_get` to VTable, Database convenience methods, `Database.init()` comptime helper, `test_vtable()`, new tests |
| `client/db/memory.zig` | Add `multi_get` direct method, vtable impl, pass in `database()`, new tests |
| `client/db/null.zig` | Add `multi_get_impl`, pass in `database()`, new tests |
| `client/db/read_only.zig` | Add `multi_get_impl` with overlay merge, pass in `database()`, new tests |
| `client/db/rocksdb.zig` | Add `multi_get_impl` stub, pass in `database()`, new test |

## Tests to Write

### adapter.zig (8 tests)
1. `"Database supports_multi_get reports false when absent"`
2. `"Database supports_multi_get reports true when present"`
3. `"Database multi_get sequential fallback returns correct results"`
4. `"Database multi_get_with_flags sequential fallback works"`
5. `"Database multi_get dispatches to vtable when present"`
6. `"Database multi_get with empty keys slice is no-op"`
7. `"Database.init with multi_get generates correct dispatch"`
8. `"Database.init without multi_get defaults to null"`

### memory.zig (4 tests)
9. `"MemoryDatabase: multi_get returns found and missing keys"`
10. `"MemoryDatabase: multi_get with empty keys slice"`
11. `"MemoryDatabase: multi_get increments reads_count"`
12. `"MemoryDatabase: multi_get via vtable interface"`

### null.zig (2 tests)
13. `"NullDb: multi_get returns all nulls"`
14. `"NullDb: multi_get with empty keys slice"`

### read_only.zig (4 tests)
15. `"ReadOnlyDb: multi_get delegates to wrapped (no overlay)"`
16. `"ReadOnlyDb: multi_get overlay takes precedence over wrapped"`
17. `"ReadOnlyDb: multi_get with mix of overlay and wrapped keys"`
18. `"ReadOnlyDb: multi_get after clear_temp_changes falls back to wrapped"`

### rocksdb.zig (1 test)
19. `"RocksDatabase: multi_get returns StorageError (unimplemented stub)"`

**Total: 19 new tests**

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Mismatched `keys.len` vs `results.len` | Medium | Runtime crash | Document invariant clearly; consider debug-mode assertion (`std.debug.assert(keys.len == results.len)`) |
| DbValue lifetime confusion — caller forgets to release | Medium | Memory leak | Document release responsibility in doc comments; test with std.testing.allocator leak detection |
| ReadOnlyDb overlay merge reads from wrong source | Low | Incorrect data | Test with keys in overlay-only, wrapped-only, both, and neither |
| Breaking existing tests by changing VTable struct layout | Very Low | Build failure | The `multi_get` field defaults to `null`, so existing vtable literals remain valid |
| Performance regression from sequential fallback | Low | Slower reads | Fallback is identical to current behavior (N individual gets); native multi_get is a pure win |

## Verification Against Acceptance Criteria

1. **Optional `multi_get` on VTable**: Step 1 adds the `?*const fn` field with `= null` default
2. **Signature matches spec**: `fn(ptr: *anyopaque, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void`
3. **Sequential fallback when null**: Step 2 implements the fallback in `multi_get_with_flags()`
4. **Same pattern as `write_batch`/`merge`**: Optional vtable slot, comptime helper, supports_* query
5. **All backends implement**: Steps 5-8 cover MemoryDatabase, NullDb, ReadOnlyDb, RocksDatabase
6. **Tests cover all specified scenarios**: 19 tests covering the 10 test cases from the context doc plus additional edge cases

## Commit Strategy

One commit per step:

1. `feat(db): add multi_get vtable slot and convenience methods to Database`
2. `feat(db): implement multi_get for MemoryDatabase`
3. `feat(db): implement multi_get for NullDb`
4. `feat(db): implement multi_get for ReadOnlyDb with overlay merge`
5. `feat(db): implement multi_get stub for RocksDatabase`

Each commit includes the relevant tests, passes `zig fmt` and `zig build test`.
