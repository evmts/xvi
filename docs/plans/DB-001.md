# DB-001: Fix ReadOnlyDbFactory strict mode OutOfMemory — Implementation Plan

## Overview

`ReadOnlyDbFactory.createDbImpl` returns `error.OutOfMemory` when `overlay_allocator` is null (strict read-only mode) because it needs to heap-allocate `OwnedContext` but has no allocator. This makes the factory completely unusable in strict mode.

**Root cause:** `ReadOnlyDbFactory.init(base, overlay_allocator)` uses `overlay_allocator` for two unrelated purposes: (1) creating the optional MemoryDatabase write overlay, and (2) heap-allocating the `OwnedContext` wrapper. When `overlay_allocator` is null (strict mode), both are impossible — but only (1) should be gated on the flag.

**Chosen approach: Option B** — Always require a non-null allocator, use a `strict_read_only: bool` flag to control overlay creation. This matches Nethermind's pattern most closely (Nethermind's `ReadOnlyDb` always allocates a MemDb; the `createInMemWriteStore` flag only controls whether `Set()` throws).

**API change:**
```zig
// Before (broken in strict mode):
pub fn init(base: DbFactory, overlay_allocator: ?std.mem.Allocator) ReadOnlyDbFactory

// After (always works):
pub fn init(base: DbFactory, allocator: std.mem.Allocator, strict_read_only: bool) ReadOnlyDbFactory
```

When `strict_read_only = true`: writes return `error.StorageError`, no overlay created.
When `strict_read_only = false`: writes go to in-memory overlay (same as current behavior with non-null allocator).

## Step-by-Step Implementation Order

### Step 1: Update `ReadOnlyDbFactory` struct fields and `init`

**File:** `client/db/factory.zig`

Change the struct from:
```zig
pub const ReadOnlyDbFactory = struct {
    base: DbFactory,
    overlay_allocator: ?std.mem.Allocator,

    pub fn init(base: DbFactory, overlay_allocator: ?std.mem.Allocator) ReadOnlyDbFactory {
        return .{ .base = base, .overlay_allocator = overlay_allocator };
    }
    // ...
};
```

To:
```zig
pub const ReadOnlyDbFactory = struct {
    base: DbFactory,
    allocator: std.mem.Allocator,
    strict_read_only: bool,

    pub fn init(base: DbFactory, allocator: std.mem.Allocator, strict_read_only: bool) ReadOnlyDbFactory {
        return .{
            .base = base,
            .allocator = allocator,
            .strict_read_only = strict_read_only,
        };
    }
    // ...
};
```

**Rationale:** The allocator is always available for `OwnedContext` heap allocation. The `strict_read_only` bool controls overlay creation (matching Nethermind's `createInMemWriteStore` flag, inverted semantics).

---

### Step 2: Fix `createDbImpl` to use `allocator` and `strict_read_only`

**File:** `client/db/factory.zig`

Replace the buggy `createDbImpl` with:
```zig
fn createDbImpl(self: *ReadOnlyDbFactory, settings: DbSettings) Error!OwnedDatabase {
    // 1. Create the base database via the base factory.
    const base_owned = try self.base.createDb(settings);
    errdefer base_owned.deinit();

    // 2. Heap-allocate the context (always possible — allocator is non-null).
    const ctx = self.allocator.create(OwnedContext) catch return error.OutOfMemory;
    errdefer self.allocator.destroy(ctx);

    // 3. Create the ReadOnlyDb wrapper.
    if (!self.strict_read_only) {
        // Overlay mode: writes buffered in MemoryDatabase overlay.
        ctx.* = .{
            .read_only = try ReadOnlyDb.init_with_write_store(base_owned.db, self.allocator),
            .base_owned = base_owned,
            .allocator = self.allocator,
        };
    } else {
        // Strict read-only mode: writes return error.StorageError.
        ctx.* = .{
            .read_only = ReadOnlyDb.init(base_owned.db),
            .base_owned = base_owned,
            .allocator = self.allocator,
        };
    }

    return .{
        .db = ctx.read_only.database(),
        .deinit_ctx = @ptrCast(ctx),
        .deinit_fn = destroyOwnedContext,
    };
}
```

**Key changes:**
- `self.allocator` is always used for `OwnedContext` allocation (never null).
- `self.strict_read_only` controls overlay creation instead of checking `overlay_allocator` nullity.
- The `return error.OutOfMemory` bug path is completely removed.

---

### Step 3: Update doc comments on `ReadOnlyDbFactory`

**File:** `client/db/factory.zig`

Update the struct-level doc comment and the `init` method doc comment to reflect the new API:
- Document that `allocator` is always required (for OwnedContext allocation and optional overlay).
- Document that `strict_read_only = true` disables the write overlay.
- Update the usage example in the struct doc comment.

---

### Step 4: Update all callers of `ReadOnlyDbFactory.init`

All callers currently pass a non-null allocator (since strict mode was broken, nobody uses it). The API change adds a third parameter.

**Files to update:**

1. **`client/db/factory.zig`** — 4 test call sites (lines ~705, 723, 740, 751)
   - Change: `ReadOnlyDbFactory.init(mem_factory.factory(), std.testing.allocator)`
   - To: `ReadOnlyDbFactory.init(mem_factory.factory(), std.testing.allocator, false)`

2. **`client/db/root.zig`** — 1 integration test (line ~177)
   - Change: `ReadOnlyDbFactory.init(mem_factory.factory(), testing.allocator)`
   - To: `ReadOnlyDbFactory.init(mem_factory.factory(), testing.allocator, false)`

3. **`client/db/bench.zig`** — 1 benchmark (line ~643)
   - Change: `ReadOnlyDbFactory.init(mem_factory.factory(), std.heap.page_allocator)`
   - To: `ReadOnlyDbFactory.init(mem_factory.factory(), std.heap.page_allocator, false)`

All existing callers get `strict_read_only = false` to preserve current overlay behavior.

---

### Step 5: Add tests for strict read-only mode via factory

**File:** `client/db/factory.zig` (append to ReadOnlyDbFactory test section)

Add the following tests:

1. **`ReadOnlyDbFactory: strict mode creates functional read-only database`**
   - Create `ReadOnlyDbFactory.init(base, allocator, true)`
   - Call `createDb` — must succeed (no more OutOfMemory)
   - Read from the database — returns null (empty base)
   - Write — returns `error.StorageError`

2. **`ReadOnlyDbFactory: strict mode reads delegate to base`**
   - Create a base MemDb with data via MemDbFactory
   - Wrap in ReadOnlyDbFactory strict mode
   - Verify reads through the read-only db see the base data

3. **`ReadOnlyDbFactory: strict mode write returns StorageError`**
   - Verify `put` returns `error.StorageError`
   - Verify `delete` returns `error.StorageError`

4. **`ReadOnlyDbFactory: strict mode deinit frees both wrapper and base (no leak)`**
   - Create strict read-only db, deinit immediately
   - `std.testing.allocator` will catch any leaks

5. **`ReadOnlyDbFactory: strict mode multiple databases from one factory`**
   - Create multiple databases from one strict factory
   - Verify each is independent and functional

---

### Step 6: Run `zig fmt` and `zig build test`

Verify:
- All code passes `zig fmt`
- All existing tests still pass (no regressions from API change)
- All new strict mode tests pass

---

## Files Summary

### Files to Create

None.

### Files to Modify

| File | Change |
|------|--------|
| `client/db/factory.zig` | Fix `ReadOnlyDbFactory` struct, `init`, `createDbImpl`; update 4 test call sites; add 5 new tests |
| `client/db/root.zig` | Update 1 integration test call site |
| `client/db/bench.zig` | Update 1 benchmark call site |

## Tests Summary

| # | Test | What It Verifies |
|---|------|-----------------|
| 1 | `ReadOnlyDbFactory: strict mode creates functional read-only database` | `createDb` succeeds with `strict_read_only = true` (BUG FIX) |
| 2 | `ReadOnlyDbFactory: strict mode reads delegate to base` | Reads pass through to base factory's database |
| 3 | `ReadOnlyDbFactory: strict mode write returns StorageError` | `put` and `delete` both error in strict mode |
| 4 | `ReadOnlyDbFactory: strict mode deinit frees both wrapper and base` | No memory leaks (testing allocator check) |
| 5 | `ReadOnlyDbFactory: strict mode multiple databases from one factory` | Factory is reusable, databases are independent |
| 6-9 | Existing overlay tests (updated call sites) | No regressions from API change |

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| **API breaking change** | All callers of `ReadOnlyDbFactory.init` must update | Only 6 call sites (4 tests, 1 integration test, 1 benchmark). All currently pass non-null allocator, so adding `false` is mechanical. |
| **Overlay allocator semantics shift** | The same allocator is now used for both OwnedContext and overlay MemoryDatabase | This is actually cleaner — one allocator serves all allocation needs. Matches Nethermind where the DI container provides a single allocator. |
| **Strict mode ReadOnlyDb.deinit is no-op** | Calling `deinit` on a strict ReadOnlyDb (no overlay) does nothing, but `destroyOwnedContext` still calls it | Safe — `ReadOnlyDb.deinit` checks `self.overlay` for null and is a no-op when there's no overlay. No behavioral change. |
| **Future callers might forget `strict_read_only` meaning** | Passing `true` when `false` was intended, or vice versa | Doc comments clearly explain both modes. The parameter name `strict_read_only` is self-documenting. |

## Verification Against Acceptance Criteria

1. **ReadOnlyDbFactory strict mode creates functional read-only databases** — Test 1 directly verifies this.
2. **Writes return `error.StorageError` in strict mode** — Test 3 verifies put and delete both error.
3. **Reads delegate to base factory's database** — Test 2 verifies read delegation.
4. **`OwnedDatabase.deinit()` cleans up both wrapper and base** — Test 4 verifies no leaks via `std.testing.allocator`.
5. **Multiple databases can be created from one strict factory** — Test 5 verifies factory reuse.
6. **No memory leaks** — All tests use `std.testing.allocator` which detects leaks.

## Commit Strategy

Single atomic commit:
```
fix(db): ReadOnlyDbFactory strict mode no longer returns OutOfMemory (DB-001)
```

This is a small, focused fix — changing 3 fields, 1 method body, updating 6 call sites, and adding 5 tests. A single commit is appropriate.
