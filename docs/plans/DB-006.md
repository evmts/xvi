# DB-006: Sorted View / Range Query Support — Implementation Plan

## Overview

Add `ISortedKeyValueStore` parity to the Guillotine DB abstraction layer, enabling
sorted range queries needed by snap sync (Phase 9) for contiguous state trie enumeration.

**Approach: Option C — Optional nullable VTable entries on `Database.VTable`.**

This follows the existing pattern for `merge`, `multi_get`, and `write_batch`:
add `first_key`, `last_key`, and `get_view_between` as optional nullable entries
on the existing `Database.VTable`. A new `SortedView` type-erased struct handles
iterator-style range traversal. No new top-level wrapper types needed.

**Nethermind reference:**
- `ISortedKeyValueStore` (IKeyValueStore.cs:120–179)
- `ISortedView` (IKeyValueStore.cs:145–179)
- `RocksdbSortedView` (RocksdbSortedView.cs)
- `DbOnTheRocksTests.IteratorWorks()` (DbOnTheRocksTests.cs:491–532)

## Step-by-Step Implementation Order

### Step 1: Add `SortedView` type-erased struct to `adapter.zig`

**File:** `client/db/adapter.zig`

Add a new `SortedView` struct (analogous to `DbIterator`) with a type-erased
vtable for sorted range iteration.

```zig
pub const SortedView = struct {
    ptr: *anyopaque,
    vtable: *const VTable,

    pub const VTable = struct {
        /// Seek to the position just before `value` in sorted order.
        /// Returns true if a valid position was found.
        /// Can only be called once, before iteration starts.
        start_before: *const fn (ptr: *anyopaque, value: []const u8) Error!bool,
        /// Advance to the next entry. On first call (without start_before),
        /// seeks to the first entry in the range. Returns null when exhausted.
        move_next: *const fn (ptr: *anyopaque) Error!?DbEntry,
        /// Release all resources held by this view.
        deinit: *const fn (ptr: *anyopaque) void,
    };

    pub fn start_before(self: *SortedView, value: []const u8) Error!bool { ... }
    pub fn move_next(self: *SortedView) Error!?DbEntry { ... }
    pub fn deinit(self: *SortedView) void { ... }

    /// Comptime type-erased constructor (same pattern as DbIterator.init).
    pub fn init(comptime T: type, ptr: *T,
        comptime start_before_fn: ...,
        comptime move_next_fn: ...,
        comptime deinit_fn: ...,
    ) SortedView { ... }
};
```

**Tests:** Unit test that `SortedView.init` creates a valid vtable dispatch (use
a trivial mock struct that returns fixed data).

**Commit:** `feat(db): add SortedView type-erased struct to adapter.zig`

---

### Step 2: Add optional sorted view VTable entries to `Database.VTable`

**File:** `client/db/adapter.zig`

Add three optional nullable fields to `Database.VTable`:

```zig
pub const VTable = struct {
    // ... existing fields ...

    /// Return the lexicographically smallest key, or null if empty.
    first_key: ?*const fn (ptr: *anyopaque) Error!?DbValue = null,

    /// Return the lexicographically largest key, or null if empty.
    last_key: ?*const fn (ptr: *anyopaque) Error!?DbValue = null,

    /// Create a sorted view over [first_key_inclusive, last_key_exclusive).
    /// Returns a SortedView that iterates entries in lexicographic key order.
    get_view_between: ?*const fn (
        ptr: *anyopaque,
        first_key_inclusive: []const u8,
        last_key_exclusive: []const u8,
    ) Error!SortedView = null,
};
```

Add corresponding convenience methods on `Database`:

```zig
pub fn supports_sorted_view(self: Database) bool { ... }
pub fn first_key(self: Database) Error!?DbValue { ... }
pub fn last_key(self: Database) Error!?DbValue { ... }
pub fn get_view_between(self: Database, first_inclusive: []const u8, last_exclusive: []const u8) Error!SortedView { ... }
```

Update `Database.init()` comptime function signature to accept optional
`first_key`, `last_key`, `get_view_between` fields, and generate wrapper
functions (same pattern as `write_batch`, `merge`, `multi_get`).

**Tests:**
- `Database.supports_sorted_view()` returns false when fields are null
- `Database.first_key()` returns `error.UnsupportedOperation` when null
- `Database.last_key()` returns `error.UnsupportedOperation` when null
- `Database.get_view_between()` returns `error.UnsupportedOperation` when null

**Commit:** `feat(db): add optional sorted view VTable entries to Database`

---

### Step 3: Implement `MemorySortedView` in `memory.zig`

**File:** `client/db/memory.zig`

Add a `MemorySortedView` struct that holds a sorted, range-filtered slice of
`DbEntry` values and implements the `SortedView` vtable:

```zig
const MemorySortedView = struct {
    entries: []DbEntry,       // sorted, range-filtered entries
    index: usize,             // current position (0 = before first)
    started: bool,            // whether iteration has begun
    started_before: bool,     // whether start_before was called
    allocator: std.mem.Allocator,

    fn start_before(self: *MemorySortedView, value: []const u8) Error!bool { ... }
    fn move_next(self: *MemorySortedView) Error!?DbEntry { ... }
    fn deinit(self: *MemorySortedView) void { ... }
};
```

**Implementation details:**
- `start_before(value)`: Binary search for the position just before `value`,
  set `index` to that position. Returns true if valid.
- `move_next()`: On first call, if `start_before` was not called, set index to 0
  and return first entry. Otherwise advance index and return entry or null.
- `deinit()`: Free the entries slice and self.

**Tests:**
- MemorySortedView with 3 entries, iterate all
- MemorySortedView with start_before, verify position
- MemorySortedView deinit frees all memory (leak check)

**Commit:** `feat(db): add MemorySortedView implementation`

---

### Step 4: Implement sorted view VTable methods on `MemoryDatabase`

**File:** `client/db/memory.zig`

Add `first_key_impl`, `last_key_impl`, and `get_view_between_impl` to
`MemoryDatabase`, and wire them into the `Database.init()` call.

```zig
fn first_key_impl(self: *MemoryDatabase) Error!?DbValue { ... }
fn last_key_impl(self: *MemoryDatabase) Error!?DbValue { ... }
fn get_view_between_impl(
    self: *MemoryDatabase,
    first_inclusive: []const u8,
    last_exclusive: []const u8,
) Error!SortedView { ... }
```

**Implementation details:**
- `first_key`: Collect all keys, sort with `Bytes.compare`, return minimum.
  (Could cache, but premature optimization — revisit later.)
- `last_key`: Same sort, return maximum.
- `get_view_between`: Collect all entries, sort by key, filter to
  `[first_inclusive, last_exclusive)` using `Bytes.compare`, allocate
  `MemorySortedView` and return as type-erased `SortedView`.

Update `database()` method to pass the three new impl functions.

**Tests:**
- first_key on empty MemoryDatabase returns null
- first_key with entries returns lexicographic minimum
- last_key on empty MemoryDatabase returns null
- last_key with entries returns lexicographic maximum
- get_view_between with full range returns all entries in order
- get_view_between with partial range returns correct subset
- get_view_between with empty range (first >= last) returns no entries
- get_view_between with single-entry range
- supports_sorted_view returns true for MemoryDatabase

**Commit:** `feat(db): implement sorted view for MemoryDatabase`

---

### Step 5: Wire sorted view into `NullDb`

**File:** `client/db/null.zig`

NullDb does NOT implement sorted view (no data). The VTable fields stay null
by default. Verify that `supports_sorted_view()` returns false and the
convenience methods return `error.UnsupportedOperation`.

**Tests:**
- NullDb: supports_sorted_view returns false
- NullDb: first_key returns UnsupportedOperation
- NullDb: last_key returns UnsupportedOperation
- NullDb: get_view_between returns UnsupportedOperation

**Commit:** `test(db): verify NullDb sorted view returns UnsupportedOperation`

---

### Step 6: Wire sorted view into `RocksDatabase` stub

**File:** `client/db/rocksdb.zig`

RocksDatabase stub does NOT implement sorted view yet (all ops return
`error.StorageError`). The VTable fields stay null by default. When real
RocksDB FFI is added, it will use `iterate_lower_bound`/`iterate_upper_bound`
on `ReadOptions` (matching Nethermind's `RocksDbReader`).

**Tests:**
- RocksDatabase: supports_sorted_view returns false

**Commit:** `test(db): verify RocksDatabase stub sorted view unsupported`

---

### Step 7: Export `SortedView` from `root.zig`

**File:** `client/db/root.zig`

Add re-export:
```zig
pub const SortedView = adapter.SortedView;
```

**Tests:** Verify `refAllDecls` still passes (existing test coverage).

**Commit:** `feat(db): export SortedView from db root module`

---

### Step 8: Integration test — Nethermind `IteratorWorks()` parity

**File:** `client/db/memory.zig` (test section)

Reproduce Nethermind's `DbOnTheRocksTests.IteratorWorks()` test:

```zig
test "MemoryDatabase: sorted view iterates entries in order (Nethermind IteratorWorks parity)" {
    // Insert 3 entries: [0,0,0], [1,1,1], [2,2,2]
    // Verify FirstKey == [0,0,0], LastKey == [2,2,2]
    // GetViewBetween([0], [9]) iterates all 3 entries in order
    // GetViewBetween([1], [2]) iterates only [1,1,1]
    // Verify SortedView.start_before semantics
}
```

Additional integration tests:
- Sorted view through snapshot (snapshot sorted state at time of creation)
- Sorted view after mutations (view reflects state at creation time)
- Binary keys with various lengths
- Empty database returns empty view

**Commit:** `test(db): add Nethermind IteratorWorks parity integration tests`

---

## Files to Create

None — all code goes into existing files.

## Files to Modify

| File | Changes |
|------|---------|
| `client/db/adapter.zig` | Add `SortedView` struct, add 3 optional VTable entries, update `Database.init()`, add convenience methods |
| `client/db/memory.zig` | Add `MemorySortedView`, add `first_key_impl`/`last_key_impl`/`get_view_between_impl`, update `database()` |
| `client/db/null.zig` | Add tests for unsupported sorted view |
| `client/db/rocksdb.zig` | Add tests for unsupported sorted view |
| `client/db/root.zig` | Add `SortedView` re-export |

## Tests to Write

### Unit Tests (adapter.zig)
1. `SortedView.init` creates valid vtable dispatch with mock
2. `Database.supports_sorted_view()` returns false when null
3. `Database.first_key()` returns UnsupportedOperation when null
4. `Database.last_key()` returns UnsupportedOperation when null
5. `Database.get_view_between()` returns UnsupportedOperation when null

### Unit Tests (memory.zig)
6. `first_key` on empty DB returns null
7. `first_key` returns lexicographic minimum
8. `last_key` on empty DB returns null
9. `last_key` returns lexicographic maximum
10. `get_view_between` full range returns all entries in order
11. `get_view_between` partial range returns correct subset
12. `get_view_between` empty range returns no entries
13. `get_view_between` single-entry range
14. `supports_sorted_view` returns true
15. `SortedView.start_before` seeks correctly
16. `SortedView.move_next` after exhaustion returns null
17. `SortedView.deinit` frees memory (leak check)

### Unit Tests (null.zig)
18. `supports_sorted_view` returns false
19. `first_key` returns UnsupportedOperation
20. `last_key` returns UnsupportedOperation
21. `get_view_between` returns UnsupportedOperation

### Unit Tests (rocksdb.zig)
22. `supports_sorted_view` returns false

### Integration Tests (memory.zig)
23. Nethermind `IteratorWorks()` parity — binary keys [0,0,0], [1,1,1], [2,2,2]
24. Sorted view with binary keys of various lengths
25. Sorted view on empty database
26. Multiple sorted views from same database are independent

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| **Performance: O(n log n) sort on every first_key/last_key/get_view_between call for MemoryDatabase** | Acceptable for Phase 0 (test/dev only). RocksDB backend will use native iterator bounds. Document that MemoryDatabase sorted view is not optimized for production. |
| **VTable size increase (3 nullable pointers)** | Minimal impact — VTable is a comptime-generated static const. Same pattern as existing optional entries. |
| **Breaking existing Database.init() callers** | New fields have `= null` defaults, so no existing callsite changes needed. Verified: NullDb, MemoryDatabase, RocksDatabase, ReadOnlyDb all use the struct-literal init pattern with defaults. |
| **SortedView lifetime / dangling references** | MemorySortedView copies entry references from the map at creation time. Entries are borrowed from the arena (valid until database deinit). Document that SortedView must be deinited before database mutations. Same lifetime model as DbIterator. |
| **start_before semantics unclear** | Nethermind's `SeekForPrev(value)` seeks to the largest key ≤ value. Implement with binary search on the sorted slice. Document behavior clearly. |
| **ReadOnlyDb sorted view** | Not implementing sorted view forwarding for ReadOnlyDb in this ticket. ReadOnlyDb.database() will not pass sorted view impl functions, so supports_sorted_view() returns false. Can be added in a follow-up if needed. |

## Verification Against Acceptance Criteria

1. **ISortedKeyValueStore parity**: `first_key`, `last_key`, `get_view_between` match Nethermind's interface semantics (inclusive lower bound, exclusive upper bound).
2. **SortedView parity**: `start_before`, `move_next`, `deinit` match Nethermind's `ISortedView` semantics.
3. **Optional capability**: Added as nullable VTable entries following existing pattern. `supports_sorted_view()` method provided.
4. **MemoryDatabase implementation**: Working sorted view with lexicographic ordering via `Bytes.compare`.
5. **NullDb/RocksDb stubs**: Return `UnsupportedOperation` / don't implement.
6. **Test coverage**: 25+ tests covering all public functions, edge cases, and Nethermind parity.
7. **No external dependencies**: No Voltaire changes needed. Uses existing `Bytes.compare`.
8. **Forward-compatible**: When real RocksDB backend is implemented, it can provide native sorted view via iterator bounds without changing the interface.
