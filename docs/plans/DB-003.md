# DB-003: Eliminate module-level `var` in null.zig

## Overview

`NullDb` in `client/db/null.zig` (lines 154-159) declares two module-level `var` values (`empty_iterator` and `null_snapshot`) solely because `DbIterator.init()` and `DbSnapshot.init()` in `adapter.zig` require `*T` (mutable pointer). Both `EmptyIterator` and `NullSnapshot` are zero-sized types with no mutable state, so the mutability is semantically incorrect.

**Approach:** Change the `ptr` parameter of `DbIterator.init` and `DbSnapshot.init` from `*T` to `*const T`. Then change the module-level `var` declarations in `null.zig` to `const`. Callers that pass `*T` (memory.zig, read_only.zig) are unaffected because Zig automatically coerces `*T` to `*const T`.

**Key technical detail:** When `*const T` is cast to `*anyopaque` via `@ptrCast`, Zig requires an intermediate `@constCast` because `*anyopaque` is a mutable opaque pointer. This is safe here because the `*anyopaque` serves only as type-erasure storage — the Wrapper functions inside `init` cast it back to the correct typed pointer (`*T` or `*const T`) before calling the user-provided function pointers. Backends that need mutation (memory.zig, read_only.zig) pass `*T` which coerces to `*const T` at the `init` call site, but their function pointers still take `*T`, so the Wrapper correctly casts `*anyopaque` → `*T`. The `@constCast` on the `*anyopaque` boundary is a type-level formality, not a soundness violation, because the actual constness is enforced by the function pointer types.

**Alternative considered (rejected):** Using `anytype` for the `ptr` parameter with comptime validation. This would work but introduces unnecessary complexity — Zig's `*T` → `*const T` coercion already handles the dual-use case cleanly.

## Step-by-step Implementation

### Step 1: Change `DbIterator.init` to accept `*const T`

**File:** `client/db/adapter.zig`, lines 216-243

Change:
```zig
pub fn init(
    comptime T: type,
    ptr: *T,
    comptime next_fn: *const fn (ptr: *T) Error!?DbEntry,
    comptime deinit_fn: *const fn (ptr: *T) void,
) DbIterator {
```

To:
```zig
pub fn init(
    comptime T: type,
    ptr: *const T,
    comptime next_fn: *const fn (ptr: *T) Error!?DbEntry,
    comptime deinit_fn: *const fn (ptr: *T) void,
) DbIterator {
```

And change the pointer cast on line 240 from:
```zig
.ptr = @ptrCast(ptr),
```
To:
```zig
.ptr = @ptrCast(@constCast(ptr)),
```

**Why only `ptr`, not the function pointer signatures?** The function pointers (`next_fn`, `deinit_fn`) define what each backend needs. Backends like `MemoryIterator` mutate through their pointer (advancing iterator state, freeing memory), so their function pointers must take `*T`. Backends like `EmptyIterator` don't mutate, but taking `*T` in their function pointer signatures is harmless (the functions just ignore the pointer). The `ptr` parameter is the only thing that needs to change because that's what null.zig passes as `&empty_iterator`.

### Step 2: Change `DbSnapshot.init` to accept `*const T`

**File:** `client/db/adapter.zig`, lines 277-319

Change:
```zig
pub fn init(
    comptime T: type,
    ptr: *T,
    comptime get_fn: *const fn (ptr: *T, key: []const u8, flags: ReadFlags) Error!?DbValue,
    comptime contains_fn: *const fn (ptr: *T, key: []const u8) Error!bool,
    comptime iterator_fn: ?*const fn (ptr: *T, ordered: bool) Error!DbIterator,
    comptime deinit_fn: *const fn (ptr: *T) void,
) DbSnapshot {
```

To:
```zig
pub fn init(
    comptime T: type,
    ptr: *const T,
    comptime get_fn: *const fn (ptr: *T, key: []const u8, flags: ReadFlags) Error!?DbValue,
    comptime contains_fn: *const fn (ptr: *T, key: []const u8) Error!bool,
    comptime iterator_fn: ?*const fn (ptr: *T, ordered: bool) Error!DbIterator,
    comptime deinit_fn: *const fn (ptr: *T) void,
) DbSnapshot {
```

And change the pointer cast on line 316 from:
```zig
.ptr = @ptrCast(ptr),
```
To:
```zig
.ptr = @ptrCast(@constCast(ptr)),
```

Same rationale as Step 1 — only the `ptr` parameter changes; function pointer signatures stay as `*T`.

### Step 3: Change null.zig module-level `var` to `const`

**File:** `client/db/null.zig`, lines 154-159

Change:
```zig
var empty_iterator = EmptyIterator{};
var null_snapshot = NullSnapshot{};
```

To:
```zig
const empty_iterator = EmptyIterator{};
const null_snapshot = NullSnapshot{};
```

And remove the comment on lines 154-157 (the "Declared `var` because..." explanation is no longer needed).

### Step 4: Verify all callers compile and tests pass

No changes needed in these files, but verify compilation:

- **`client/db/memory.zig`** — Lines 245, 254 (`DbIterator.init`), line 274 (`DbSnapshot.init`): passes heap-allocated `*T` pointers which coerce to `*const T` automatically.
- **`client/db/read_only.zig`** — Line 352 (`DbIterator.init`), line 267 (`DbSnapshot.init`): same pattern, heap-allocated `*T` pointers coerce automatically.

## Files to Modify

| File | Change | Lines |
|------|--------|-------|
| `client/db/adapter.zig` | `ptr: *T` → `ptr: *const T` in `DbIterator.init`, add `@constCast` | 218, 240 |
| `client/db/adapter.zig` | `ptr: *T` → `ptr: *const T` in `DbSnapshot.init`, add `@constCast` | 279, 316 |
| `client/db/null.zig` | `var` → `const` for `empty_iterator` and `null_snapshot`, remove stale comment | 154-159 |

## Files NOT Modified (verify only)

| File | Why | Call sites |
|------|-----|------------|
| `client/db/memory.zig` | `*T` coerces to `*const T` automatically | Lines 245, 254, 274 |
| `client/db/read_only.zig` | `*T` coerces to `*const T` automatically | Lines 267, 352 |

## Tests

No new tests are needed — this is a pure refactor that preserves all existing behavior. The existing test suite provides full coverage:

| File | Tests | Purpose |
|------|-------|---------|
| `client/db/adapter.zig` | 30 tests | Vtable dispatch, WriteBatch, OwnedDatabase |
| `client/db/null.zig` | 9 tests | NullDb reads, writes, iterator, snapshot |
| `client/db/memory.zig` | 23 tests | MemoryDatabase CRUD, iterator, snapshot |
| `client/db/read_only.zig` | 25 tests | ReadOnlyDb strict mode, overlay, iterator, snapshot |

**Key tests that exercise the changed code paths:**
- `"NullDb: iterator yields no entries"` — exercises `DbIterator.init` with const pointer
- `"NullDb: snapshot returns null and empty iterator"` — exercises both `DbIterator.init` and `DbSnapshot.init` with const pointers
- `"MemoryDatabase: iterator yields entries (unordered)"` — exercises `DbIterator.init` with mutable pointer (coercion)
- `"MemoryDatabase: snapshot isolates later writes"` — exercises `DbSnapshot.init` with mutable pointer (coercion)
- `"ReadOnlyDb: iterator merges overlay and wrapped without duplicates"` — exercises `DbIterator.init` with mutable pointer (coercion)
- `"ReadOnlyDb: snapshot captures overlay and wrapped state"` — exercises `DbSnapshot.init` with mutable pointer (coercion)

## Verification

```bash
# 1. Build compiles cleanly
zig build

# 2. All DB tests pass
zig build test 2>&1 | grep -E "(PASS|FAIL|error)"

# 3. Verify no module-level var remains in null.zig
grep -n "^    var " client/db/null.zig  # should return nothing

# 4. Verify ptr parameter is *const T in adapter.zig
grep -A1 "pub fn init" client/db/adapter.zig | grep "ptr:"  # should show *const T
```

## Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|------------|------------|
| `@constCast` on truly const data followed by mutation through `*anyopaque` | **None** — the Wrapper functions cast `*anyopaque` → `*T` only for backends whose function pointers take `*T`, meaning those backends originally passed a mutable `*T` that was coerced to `*const T`. NullDb's function pointers take `*EmptyIterator`/`*NullSnapshot` but never mutate through them. | The type system enforces this: if a backend's function pointers take `*T`, the backend must have passed a legitimately mutable pointer at the `init` call site. |
| Zig 0.15 pointer coercion rules differ from expected | **Low** — `*T` → `*const T` coercion is fundamental Zig behavior, documented and stable. | Compilation will fail immediately if this doesn't work, caught in Step 4. |
| Future backends that need `*const T` function pointers | **Low** — the function pointer signatures remain `*T`, so a future read-only backend would still need `*T` in its function pointers even though it doesn't mutate. This is harmless. | If this becomes a pattern, a follow-up ticket could parameterize constness, but YAGNI for now. |

## Acceptance Criteria Checklist

- [ ] `DbIterator.init` accepts `*const T` for the pointer parameter
- [ ] `DbSnapshot.init` accepts `*const T` for the pointer parameter
- [ ] `null.zig` uses `const` for `empty_iterator` and `null_snapshot`
- [ ] All 87+ existing DB tests pass unchanged
- [ ] `zig build` compiles cleanly with no warnings
- [ ] No behavioral changes — pure refactor
