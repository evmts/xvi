# DB-002: Implement DbFactory for Pluggable Database Creation

## Overview

Implement a `DbFactory` interface that decouples database instantiation from concrete backend types. This mirrors Nethermind's `IDbFactory` pattern, enabling diagnostic modes (MemDb, ReadOnly, NullDb) and test isolation without changing consumer code.

### Key Design Decision: Comptime Generic Factory

Nethermind's `CreateColumnsDb<T>(DbSettings)` uses C# runtime generics. In Zig, `ColumnsDb(T)` is comptime-generic — vtable function pointers cannot accept comptime parameters. Our solution:

**Use a comptime-generic factory interface** (not a vtable). The factory is a `fn` type parameter, not a type-erased interface. This is idiomatic Zig and matches the existing comptime DI pattern used throughout the EVM code.

However, for runtime polymorphism (selecting MemDb vs ReadOnly mode at startup), we also need a **vtable-based `DbFactory`** for the `createDb` path, and a separate **comptime dispatch** for `createColumnsDb`. This hybrid approach:

1. `DbFactory` — vtable interface for `createDb(DbSettings) -> Database` (runtime dispatch)
2. `createColumnsDb` — handled via comptime generic helper functions on each concrete factory

This matches how Nethermind wires things: `IDbFactory` is resolved once at startup (DI container), then used uniformly. In Zig, the concrete factory type is known at init time, so comptime generics work for columns.

### Ownership Model

The factory returns `OwnedDatabase` — a `Database` interface paired with a `deinit` callback. This ensures callers can clean up factory-created databases without knowing the concrete type. The factory itself tracks an arena allocator for all created instances.

## Step-by-Step Implementation

### Step 1: Define `OwnedDatabase` struct in `adapter.zig`

**File:** `client/db/adapter.zig`

A lightweight wrapper pairing a `Database` vtable interface with a cleanup callback.

```zig
/// A Database interface paired with an ownership handle for cleanup.
///
/// Returned by factory methods when the factory owns the backing storage.
/// Callers must call `deinit()` when done, or rely on the factory's
/// bulk cleanup if using arena-based allocation.
pub const OwnedDatabase = struct {
    db: Database,
    deinit_ctx: ?*anyopaque = null,
    deinit_fn: ?*const fn (ctx: ?*anyopaque) void = null,

    /// Release the owned database resources.
    pub fn deinit(self: OwnedDatabase) void {
        if (self.deinit_fn) |f| {
            f(self.deinit_ctx);
        }
    }

    /// Create a non-owned wrapper (for databases not created by a factory).
    pub fn unmanaged(db: Database) OwnedDatabase {
        return .{ .db = db };
    }
};
```

**Tests:**
- `OwnedDatabase.deinit` calls cleanup fn
- `OwnedDatabase.unmanaged` wraps without cleanup
- `OwnedDatabase.deinit` is safe with null deinit_fn

### Step 2: Define `DbFactory` vtable interface in new file `factory.zig`

**File:** `client/db/factory.zig` (new)

```zig
pub const DbFactory = struct {
    ptr: *anyopaque,
    vtable: *const VTable,

    pub const VTable = struct {
        /// Create a single-column database.
        create_db: *const fn (ptr: *anyopaque, settings: DbSettings) Error!OwnedDatabase,
        /// Get the full filesystem path for a database.
        get_full_db_path: *const fn (ptr: *anyopaque, settings: DbSettings) []const u8,
        /// Release all factory-owned resources (optional bulk cleanup).
        deinit: *const fn (ptr: *anyopaque) void,
    };

    pub fn createDb(self: DbFactory, settings: DbSettings) Error!OwnedDatabase { ... }
    pub fn getFullDbPath(self: DbFactory, settings: DbSettings) []const u8 { ... }
    pub fn deinit(self: DbFactory) void { ... }

    /// Comptime init helper (same pattern as Database.init).
    pub fn init(comptime T: type, ptr: *T, comptime fns: struct { ... }) DbFactory { ... }
};
```

**Tests:**
- Vtable dispatch works (mock factory)
- `init` comptime helper generates correct wrappers

### Step 3: Implement `MemDbFactory` in `factory.zig`

**In the same file:** `client/db/factory.zig`

```zig
pub const MemDbFactory = struct {
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) MemDbFactory { ... }
    pub fn deinit(self: *MemDbFactory) void { ... }
    pub fn factory(self: *MemDbFactory) DbFactory { ... }

    // Creates a MemoryDatabase, returns OwnedDatabase
    fn createDb(self: *MemDbFactory, settings: DbSettings) Error!OwnedDatabase { ... }

    // Comptime generic: creates MemColumnsDb(T)
    pub fn createColumnsDb(self: *MemDbFactory, comptime T: type, db_name: DbName) MemColumnsDb(T) { ... }

    fn getFullDbPath(_: *MemDbFactory, settings: DbSettings) []const u8 { ... }
};
```

The `createDb` method:
1. Allocates a `MemoryDatabase` on the heap (using self.allocator)
2. Returns `OwnedDatabase` with deinit_fn that frees the MemoryDatabase
3. The returned `Database` interface works normally

**Tests:**
- `MemDbFactory.createDb` returns a functional database
- Created database supports put/get/delete
- `OwnedDatabase.deinit` frees the MemoryDatabase (no leak)
- `MemDbFactory.createColumnsDb` returns functional MemColumnsDb
- Multiple databases can be created from one factory
- Memory leak check with testing_allocator

### Step 4: Implement `NullDbFactory` in `factory.zig`

```zig
pub const NullDbFactory = struct {
    /// Sentinel factory — all creation attempts return error.
    /// Matches Nethermind's NullRocksDbFactory singleton.

    pub fn init() NullDbFactory { ... }
    pub fn factory(self: *NullDbFactory) DbFactory { ... }

    fn createDb(_: *NullDbFactory, _: DbSettings) Error!OwnedDatabase {
        return error.UnsupportedOperation;
    }

    fn getFullDbPath(_: *NullDbFactory, settings: DbSettings) []const u8 {
        return settings.path;
    }

    fn deinitNoop(_: *NullDbFactory) void {}
};
```

**Tests:**
- `NullDbFactory.createDb` returns `error.UnsupportedOperation`
- `getFullDbPath` returns settings.path
- deinit is safe no-op

### Step 5: Implement `ReadOnlyDbFactory` in `factory.zig`

```zig
pub const ReadOnlyDbFactory = struct {
    /// Decorator factory — wraps another factory, returns ReadOnlyDb views.
    /// Matches Nethermind's ReadOnlyDbFactory decorator pattern.
    base: DbFactory,
    overlay_allocator: ?std.mem.Allocator,

    pub fn init(base: DbFactory, overlay_allocator: ?std.mem.Allocator) ReadOnlyDbFactory { ... }
    pub fn factory(self: *ReadOnlyDbFactory) DbFactory { ... }

    fn createDb(self: *ReadOnlyDbFactory, settings: DbSettings) Error!OwnedDatabase {
        // 1. Create DB via base factory
        // 2. Wrap in ReadOnlyDb (with or without overlay)
        // 3. Return OwnedDatabase with cleanup for both wrapper and base
    }
};
```

**Tests:**
- `ReadOnlyDbFactory.createDb` returns a read-only database
- Writes to created database return error (strict mode)
- With overlay_allocator: writes go to overlay, reads merge
- Base factory's database is properly cleaned up on deinit
- Decorator chains correctly (ReadOnly wrapping MemDb)

### Step 6: Add `createColumnsDb` comptime helper

Since vtables can't have comptime params, provide a standalone comptime helper:

```zig
/// Create a ColumnsDb using the appropriate factory pattern.
/// This is a comptime function — the column enum type T must be known at compile time.
pub fn createColumnsDb(
    comptime T: type,
    comptime FactoryType: type,
    factory_ptr: *FactoryType,
    db_name: DbName,
) !ColumnsDb(T) { ... }
```

Each concrete factory type provides its own `createColumnsDb` method. The standalone helper dispatches via `@hasDecl` comptime check.

**Tests:**
- Comptime helper works with MemDbFactory
- Returns functional ColumnsDb for ReceiptsColumns
- Returns functional ColumnsDb for BlobTxsColumns

### Step 7: Export from `root.zig`

**File:** `client/db/root.zig`

Add exports:
```zig
pub const DbFactory = factory.DbFactory;
pub const OwnedDatabase = adapter.OwnedDatabase;
pub const MemDbFactory = factory.MemDbFactory;
pub const NullDbFactory = factory.NullDbFactory;
pub const ReadOnlyDbFactory = factory.ReadOnlyDbFactory;
```

Update the `test` block to include `factory.zig`.

**Tests:**
- `refAllDecls` catches compilation errors in new module

### Step 8: Integration test — factory + provider wiring

Add an integration test showing the full DI pattern:

```zig
test "MemDbFactory populates DbProvider" {
    var mem_factory = MemDbFactory.init(testing.allocator);
    defer mem_factory.deinit();

    var provider = DbProvider.init();

    // Create databases via factory
    const state_db = try mem_factory.factory().createDb(DbSettings.init(.state, "state"));
    defer state_db.deinit();
    provider.register(.state, state_db.db);

    const code_db = try mem_factory.factory().createDb(DbSettings.init(.code, "code"));
    defer code_db.deinit();
    provider.register(.code, code_db.db);

    // Use provider as normal
    const db = try provider.get(.state);
    try db.put("key", "value");
    const val = try db.get("key");
    try testing.expect(val != null);
    val.?.release();
}
```

## Files to Create

| File | Description |
|------|-------------|
| `client/db/factory.zig` | DbFactory vtable, MemDbFactory, NullDbFactory, ReadOnlyDbFactory |

## Files to Modify

| File | Change |
|------|--------|
| `client/db/adapter.zig` | Add `OwnedDatabase` struct |
| `client/db/root.zig` | Export new types, add factory import |

## Tests to Write

| Test | Location | Description |
|------|----------|-------------|
| OwnedDatabase basics | `adapter.zig` | deinit calls fn, unmanaged wraps, null deinit safe |
| DbFactory vtable dispatch | `factory.zig` | Mock factory, init helper, all methods dispatch |
| MemDbFactory.createDb | `factory.zig` | Creates functional MemoryDatabase, no leaks |
| MemDbFactory.createColumnsDb | `factory.zig` | Creates functional MemColumnsDb for enum types |
| MemDbFactory multiple creates | `factory.zig` | Multiple databases from one factory |
| NullDbFactory.createDb | `factory.zig` | Returns UnsupportedOperation error |
| NullDbFactory.getFullDbPath | `factory.zig` | Returns settings.path |
| ReadOnlyDbFactory strict | `factory.zig` | Writes error, reads delegate |
| ReadOnlyDbFactory with overlay | `factory.zig` | Writes to overlay, reads merge |
| ReadOnlyDbFactory cleanup | `factory.zig` | Both wrapper and base cleaned up |
| Factory + Provider integration | `factory.zig` | Full wiring pattern |

## Risks and Mitigations

### Risk 1: Heap allocation for factory-created databases
**Issue:** `MemDbFactory.createDb` must heap-allocate `MemoryDatabase` so it can return a type-erased `Database`. This is one allocation per database — acceptable since databases are long-lived (created once at startup).
**Mitigation:** Use the factory's allocator. Document that callers must call `OwnedDatabase.deinit()`.

### Risk 2: ReadOnlyDbFactory double-ownership
**Issue:** `ReadOnlyDbFactory` creates a base database AND wraps it in `ReadOnlyDb`. Both need cleanup. If the wrapper's deinit is called but not the base's, we leak.
**Mitigation:** The `OwnedDatabase` returned by `ReadOnlyDbFactory` owns both the `ReadOnlyDb` wrapper and the base `OwnedDatabase`. Its deinit cleans up both in the correct order (wrapper first, then base).

### Risk 3: ColumnsDb comptime vs runtime tension
**Issue:** `CreateColumnsDb<T>` can't go through a vtable because `T` is comptime. This means factory consumers must know the concrete factory type at compile time for column operations.
**Mitigation:** This matches real usage — the concrete factory is selected once at startup (via config/diagnostic mode), then used throughout. Column DB creation always happens in typed initialization code, not generic runtime loops. Document this limitation clearly.

### Risk 4: Lifetime of Database returned by factory
**Issue:** The `Database` vtable handle inside `OwnedDatabase` points into the heap-allocated backend. If `OwnedDatabase.deinit()` is called while someone still holds the `Database`, use-after-free.
**Mitigation:** Follow the existing pattern (e.g., `MemoryDatabase.database()` returns a non-owning handle). Document that `Database` handles are valid only while the `OwnedDatabase` is alive. This is identical to the existing `MemoryDatabase` / `database()` contract.

## Verification Against Acceptance Criteria

1. **DbFactory interface exists** — `DbFactory` vtable struct in `factory.zig` ✓
2. **MemDbFactory creates functional MemoryDatabase/MemColumnsDb** — Tests verify put/get/delete ✓
3. **NullDbFactory returns error on creation** — Test verifies `error.UnsupportedOperation` ✓
4. **ReadOnlyDbFactory wraps base factory** — Decorator pattern with strict and overlay modes ✓
5. **Test isolation enabled** — MemDbFactory provides in-memory backends for tests ✓
6. **Diagnostic modes supported** — Factory swap at startup (MemDb/ReadOnly/Null) ✓
7. **No breaking changes** — All existing code continues to work; factory is additive ✓
8. **All public functions tested** — Every factory method has corresponding test ✓
9. **No `catch {}` or silent error suppression** — All errors propagated via `try` ✓
10. **Memory safety** — testing_allocator leak detection in all tests ✓
