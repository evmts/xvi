# DB-007: Implement ordered iteration for ReadOnlyDb with overlay

## Overview

Implement a `MergeSortIterator` in `read_only.zig` that yields entries from both the overlay (`MemoryDatabase`) and wrapped DB in lexicographic key order, deduplicating with overlay precedence. This removes the `error.UnsupportedOperation` guard at line 349 and enables ordered iteration through read-only views — required by snap sync (`devp2p/caps/snap.md`) for serving `GetAccountRange` and `GetStorageRanges`.

**Approach**: Two-iterator merge-sort with lookahead buffering.

Both sub-iterators (overlay's `OrderedIterator` and wrapped DB's ordered iterator) already produce entries in sorted order. The `MergeSortIterator` performs an O(n+m) merge: it pre-fetches one entry from each sub-iterator and on each `next()` call yields the smaller key, advancing that sub-iterator. When keys are equal, the overlay entry wins (consistent with `get()` semantics and Nethermind's `.Union()` precedence) and the wrapped entry is released.

**Nethermind reference**: `ReadOnlyDb.GetAll()` uses `_memDb.GetAll().Union(wrappedDb.GetAll())` — LINQ `Union` deduplicates with first-source precedence (memDb). Our merge-sort achieves the same semantics while preserving key order.

**Key primitive**: `Bytes.compare(a, b) -> i8` (Voltaire, lexicographic byte comparison) — already used by `memory.zig:db_entry_less_than`.

## Step-by-step Implementation Order

### Step 1: Add `MergeSortIterator` struct to `read_only.zig`

**File**: `client/db/read_only.zig`

Add a new struct after the existing `ReadOnlyIterator` (after line 259):

```zig
const MergeSortIterator = struct {
    overlay_iter: DbIterator,
    wrapped_iter: DbIterator,
    overlay_current: ?DbEntry,
    wrapped_current: ?DbEntry,
    allocator: std.mem.Allocator,

    fn next(self: *MergeSortIterator) Error!?DbEntry { ... }
    fn deinit(self: *MergeSortIterator) void { ... }
};
```

**Algorithm for `next()`**:
1. If both `overlay_current` and `wrapped_current` are non-null:
   - Compare keys with `Bytes.compare(overlay_current.key.bytes, wrapped_current.key.bytes)`
   - If `< 0` (overlay smaller): yield overlay entry, advance overlay (`overlay_current = try overlay_iter.next()`)
   - If `> 0` (wrapped smaller): yield wrapped entry, advance wrapped
   - If `== 0` (equal keys): yield overlay entry (precedence), release wrapped entry, advance both
2. If only overlay has an entry: yield it, advance overlay
3. If only wrapped has an entry: yield it, advance wrapped
4. If neither: return `null` (exhausted)

**Algorithm for `deinit()`**:
1. Release any buffered `overlay_current` entry (if non-null)
2. Release any buffered `wrapped_current` entry (if non-null)
3. Call `overlay_iter.deinit()` and `wrapped_iter.deinit()`
4. Free self via `allocator.destroy(self)`

**No tests yet** — the struct is internal. Tests come in Step 3.

**Commit**: `feat(db): add MergeSortIterator struct for ordered overlay iteration`

---

### Step 2: Wire `MergeSortIterator` into `iterator_impl`

**File**: `client/db/read_only.zig`

Modify `iterator_impl` (lines 347-365) to handle the `ordered=true` + overlay case instead of returning `error.UnsupportedOperation`:

```zig
fn iterator_impl(self: *ReadOnlyDb, ordered: bool) Error!DbIterator {
    if (self.overlay) |ov| {
        const allocator = self.overlay_allocator orelse return error.OutOfMemory;
        if (ordered) {
            // Merge-sort: get ordered iterators from both sources
            var overlay_iter = try ov.database().iterator(true);
            errdefer overlay_iter.deinit();
            var wrapped_iter = try self.wrapped.iterator(true);
            errdefer wrapped_iter.deinit();

            // Pre-fetch first entry from each (lookahead)
            const overlay_first = try overlay_iter.next();
            const wrapped_first = try wrapped_iter.next();

            const ms_iter = allocator.create(MergeSortIterator) catch return error.OutOfMemory;
            ms_iter.* = .{
                .overlay_iter = overlay_iter,
                .wrapped_iter = wrapped_iter,
                .overlay_current = overlay_first,
                .wrapped_current = wrapped_first,
                .allocator = allocator,
            };
            return DbIterator.init(MergeSortIterator, ms_iter, MergeSortIterator.next, MergeSortIterator.deinit);
        }
        // Unordered: existing ReadOnlyIterator (two-phase overlay-then-wrapped)
        var overlay_iter = try ov.database().iterator(false);
        errdefer overlay_iter.deinit();
        var wrapped_iter = try self.wrapped.iterator(false);
        errdefer wrapped_iter.deinit();

        const ro_iter = allocator.create(ReadOnlyIterator) catch return error.OutOfMemory;
        ro_iter.* = .{
            .overlay_iter = overlay_iter,
            .wrapped_iter = wrapped_iter,
            .allocator = allocator,
        };
        return DbIterator.init(ReadOnlyIterator, ro_iter, ReadOnlyIterator.next, ReadOnlyIterator.deinit);
    }
    return self.wrapped.iterator(ordered);
}
```

Key changes:
- Remove the `if (ordered) return error.UnsupportedOperation;` guard
- Add ordered branch that creates `MergeSortIterator` with `ordered=true` sub-iterators
- Keep existing unordered path with `ReadOnlyIterator` unchanged

**Commit**: `feat(db): wire MergeSortIterator into ReadOnlyDb.iterator_impl`

---

### Step 3: Replace the existing "unsupported" test with ordered iteration tests

**File**: `client/db/read_only.zig`

**Replace** the test at lines 909-918 (`"ReadOnlyDb: iterator ordered is unsupported with overlay"`) with a new test that verifies ordered iteration works:

```zig
test "ReadOnlyDb: iterator ordered merges overlay and wrapped in key order" {
    // Setup: wrapped has {a, c}, overlay has {b, c_override}
    // Expected ordered output: a(wrapped), b(overlay), c(overlay_value)
    var mem = MemoryDatabase.init(std.testing.allocator, .state);
    defer mem.deinit();
    try mem.put("a", "base_a");
    try mem.put("c", "base_c");

    var ro = try ReadOnlyDb.init_with_write_store(mem.database(), std.testing.allocator);
    defer ro.deinit();
    const iface = ro.database();
    try iface.put("b", "overlay_b");
    try iface.put("c", "overlay_c");  // overlay overrides wrapped

    var it = try iface.iterator(true);
    defer it.deinit();

    // Entry 1: "a" from wrapped
    const e1 = (try it.next()).?;
    defer e1.release();
    try std.testing.expectEqualStrings("a", e1.key.bytes);
    try std.testing.expectEqualStrings("base_a", e1.value.bytes);

    // Entry 2: "b" from overlay
    const e2 = (try it.next()).?;
    defer e2.release();
    try std.testing.expectEqualStrings("b", e2.key.bytes);
    try std.testing.expectEqualStrings("overlay_b", e2.value.bytes);

    // Entry 3: "c" from overlay (precedence over wrapped)
    const e3 = (try it.next()).?;
    defer e3.release();
    try std.testing.expectEqualStrings("c", e3.key.bytes);
    try std.testing.expectEqualStrings("overlay_c", e3.value.bytes);

    // Exhausted
    try std.testing.expect((try it.next()) == null);
}
```

**Commit**: `test(db): replace unsupported ordered iteration test with merge-sort verification`

---

### Step 4: Add edge case tests for `MergeSortIterator`

**File**: `client/db/read_only.zig`

Add the following additional tests after the test from Step 3:

#### Test 4a: Ordered iteration with empty overlay

```zig
test "ReadOnlyDb: iterator ordered with empty overlay yields wrapped entries in order" {
    var mem = MemoryDatabase.init(std.testing.allocator, .state);
    defer mem.deinit();
    try mem.put("b", "2");
    try mem.put("a", "1");

    var ro = try ReadOnlyDb.init_with_write_store(mem.database(), std.testing.allocator);
    defer ro.deinit();
    // Overlay is empty — all entries come from wrapped

    var it = try ro.database().iterator(true);
    defer it.deinit();

    const e1 = (try it.next()).?;
    defer e1.release();
    try std.testing.expectEqualStrings("a", e1.key.bytes);

    const e2 = (try it.next()).?;
    defer e2.release();
    try std.testing.expectEqualStrings("b", e2.key.bytes);

    try std.testing.expect((try it.next()) == null);
}
```

#### Test 4b: Ordered iteration with empty wrapped

```zig
test "ReadOnlyDb: iterator ordered with empty wrapped yields overlay entries in order" {
    var mem = MemoryDatabase.init(std.testing.allocator, .state);
    defer mem.deinit();
    // Wrapped is empty

    var ro = try ReadOnlyDb.init_with_write_store(mem.database(), std.testing.allocator);
    defer ro.deinit();
    const iface = ro.database();
    try iface.put("z", "26");
    try iface.put("a", "1");

    var it = try iface.iterator(true);
    defer it.deinit();

    const e1 = (try it.next()).?;
    defer e1.release();
    try std.testing.expectEqualStrings("a", e1.key.bytes);

    const e2 = (try it.next()).?;
    defer e2.release();
    try std.testing.expectEqualStrings("z", e2.key.bytes);

    try std.testing.expect((try it.next()) == null);
}
```

#### Test 4c: Ordered iteration with both empty

```zig
test "ReadOnlyDb: iterator ordered with both empty returns null immediately" {
    var mem = MemoryDatabase.init(std.testing.allocator, .state);
    defer mem.deinit();

    var ro = try ReadOnlyDb.init_with_write_store(mem.database(), std.testing.allocator);
    defer ro.deinit();

    var it = try ro.database().iterator(true);
    defer it.deinit();

    try std.testing.expect((try it.next()) == null);
}
```

#### Test 4d: Ordered iteration — all keys duplicated (overlay wins for all)

```zig
test "ReadOnlyDb: iterator ordered all duplicate keys yields overlay values" {
    var mem = MemoryDatabase.init(std.testing.allocator, .state);
    defer mem.deinit();
    try mem.put("x", "wrapped_x");
    try mem.put("y", "wrapped_y");

    var ro = try ReadOnlyDb.init_with_write_store(mem.database(), std.testing.allocator);
    defer ro.deinit();
    const iface = ro.database();
    try iface.put("x", "overlay_x");
    try iface.put("y", "overlay_y");

    var it = try iface.iterator(true);
    defer it.deinit();

    const e1 = (try it.next()).?;
    defer e1.release();
    try std.testing.expectEqualStrings("x", e1.key.bytes);
    try std.testing.expectEqualStrings("overlay_x", e1.value.bytes);

    const e2 = (try it.next()).?;
    defer e2.release();
    try std.testing.expectEqualStrings("y", e2.key.bytes);
    try std.testing.expectEqualStrings("overlay_y", e2.value.bytes);

    try std.testing.expect((try it.next()) == null);
}
```

#### Test 4e: Memory leak check for ordered iterator with overlay

```zig
test "ReadOnlyDb: iterator ordered deinit frees all resources (leak check)" {
    var mem = MemoryDatabase.init(std.testing.allocator, .state);
    defer mem.deinit();
    try mem.put("a", "val_a_with_some_length");
    try mem.put("b", "val_b_with_some_length");

    var ro = try ReadOnlyDb.init_with_write_store(mem.database(), std.testing.allocator);
    defer ro.deinit();
    const iface = ro.database();
    try iface.put("b", "overlay_b_with_some_length");
    try iface.put("c", "overlay_c_with_some_length");

    // Create and immediately deinit without consuming — must not leak
    var it = try iface.iterator(true);
    it.deinit();

    // Create, partially consume, then deinit — must not leak
    var it2 = try iface.iterator(true);
    const e1 = try it2.next();
    if (e1) |e| e.release();
    it2.deinit();
}
```

**Commit**: `test(db): add edge case tests for MergeSortIterator`

---

### Step 5: Verify existing unordered tests still pass

**File**: No changes — verification only.

Run the full test suite for `read_only.zig` to confirm:
1. The existing unordered iterator test (`"ReadOnlyDb: iterator merges overlay and wrapped without duplicates"`) still passes
2. All other existing tests are unaffected
3. No memory leaks detected by the testing allocator

```bash
zig test client/db/read_only.zig --dep primitives -Mprimitivesroot=... 2>&1 | head -50
```

Or via the build system:
```bash
zig build test 2>&1 | grep -E "read_only|PASS|FAIL"
```

**No commit** — verification step only.

---

## Files to Create

None — all code goes into the existing `client/db/read_only.zig`.

## Files to Modify

| File | Changes |
|------|---------|
| `client/db/read_only.zig` | Add `MergeSortIterator` struct (~45 lines), modify `iterator_impl` to use it for ordered+overlay case (~15 lines changed), replace 1 test + add 5 new tests (~120 lines) |

## Tests to Write

| # | Test Name | What It Verifies |
|---|-----------|-----------------|
| 1 | `ReadOnlyDb: iterator ordered merges overlay and wrapped in key order` | Core merge-sort with overlay precedence on duplicate key |
| 2 | `ReadOnlyDb: iterator ordered with empty overlay yields wrapped entries in order` | Degenerate case — overlay contributes nothing |
| 3 | `ReadOnlyDb: iterator ordered with empty wrapped yields overlay entries in order` | Degenerate case — wrapped contributes nothing |
| 4 | `ReadOnlyDb: iterator ordered with both empty returns null immediately` | Both empty — immediate exhaustion |
| 5 | `ReadOnlyDb: iterator ordered all duplicate keys yields overlay values` | All keys overlap — overlay wins for every entry |
| 6 | `ReadOnlyDb: iterator ordered deinit frees all resources (leak check)` | No memory leaks on early deinit or partial consumption |

**Replaced**: `"ReadOnlyDb: iterator ordered is unsupported with overlay"` (currently asserts `error.UnsupportedOperation`)

## Risks and Mitigations

| Risk | Severity | Mitigation |
|------|----------|------------|
| **Buffered entry lifetime**: `overlay_current`/`wrapped_current` hold `DbEntry` values that must be released on `deinit` even if never yielded | High | `deinit()` explicitly checks and releases any non-null buffered entries before cleaning up sub-iterators |
| **Sub-iterator error during `next()` pre-fetch**: If advancing a sub-iterator after yielding an entry fails, the yielded entry is already consumed by the caller — no double-free risk. But the buffered entry on the *other* side must still be releasable via `deinit()` | Medium | Error propagation via `try`; `deinit()` handles partial state. `errdefer` is not needed for the pre-fetched entries because `deinit()` always cleans up |
| **MemoryDatabase's `OrderedIterator` allocates a sorted slice**: For large overlays, this is O(n log n) sort + O(n) allocation | Low | Already the cost of ordered iteration. Same behavior as `memory.zig:make_iterator(ordered=true)`. No regression |
| **Entry borrowing**: `DbEntry.key.bytes` and `.value.bytes` from `MemoryDatabase`'s `OrderedIterator` are borrowed from the arena — they remain valid as long as the `MemoryDatabase` is alive | Low | Documented in `MemoryDatabase`. Same lifetime contract as unordered iteration. Tests use `testing.allocator` which detects use-after-free |
| **Breaking the removed `error.UnsupportedOperation` test**: Code that relied on ordered iteration being unsupported will silently start succeeding | Low | This is the intended behavior change. No external callers should depend on `UnsupportedOperation` — it was a placeholder |

## Verification Against Acceptance Criteria

1. **Merge-sort iterator implemented**: `MergeSortIterator` performs O(n+m) merge of two ordered sub-iterators
2. **Overlay precedence**: When keys are equal, overlay value is yielded and wrapped entry is released (tested explicitly)
3. **Key order**: Entries are yielded in lexicographic order using `Bytes.compare` (tested with interleaved keys)
4. **Guard removed**: `if (ordered) return error.UnsupportedOperation` line deleted
5. **No regressions**: Existing unordered iterator tests still pass; existing ordered-without-overlay path unchanged
6. **Memory safety**: Leak check test with `std.testing.allocator`; `deinit` handles partial consumption
7. **Snap sync ready**: Ordered iteration through read-only views enables `GetAccountRange`/`GetStorageRanges` serving
