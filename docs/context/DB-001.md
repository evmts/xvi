# DB-001: IColumnsDb<T> Column Family Abstraction — Research Context

## Ticket Summary

Implement a `ColumnsDb` struct generic over an enum type that provides column family support for databases like ReceiptsDb (3 columns) and BlobTransactionsDb (3 columns). The current DB layer only has flat key-value stores with no multi-column support.

## Nethermind Reference Files

### Core Interfaces

| File | Purpose |
|------|---------|
| `nethermind/src/Nethermind/Nethermind.Db/IColumnsDb.cs` | Main generic interface: `IColumnsDb<TKey>` with `GetColumnDb()`, `ColumnKeys`, `StartWriteBatch()`, `CreateSnapshot()` |
| `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` | Base `IDb` interface (each column is an `IDb`) + `IDbMeta` with `DbMetric` |
| `nethermind/src/Nethermind/Nethermind.Db/IReadOnlyDb.cs` | `IReadOnlyColumnDb<T>` — read-only wrapper interface |

### Column Enum Definitions

| File | Enum | Values |
|------|------|--------|
| `nethermind/src/Nethermind/Nethermind.Db/ReceiptsColumns.cs` | `ReceiptsColumns` | `Default`, `Transactions`, `Blocks` |
| `nethermind/src/Nethermind/Nethermind.Db/BlobTxsColumns.cs` | `BlobTxsColumns` | `FullBlobTxs`, `LightBlobTxs`, `ProcessedTxs` |

### Implementations

| File | Purpose |
|------|---------|
| `nethermind/src/Nethermind/Nethermind.Db/MemColumnsDb.cs` | In-memory implementation — `Dictionary<TKey, IDb>` of `MemDb` instances. Lazily creates columns on `GetColumnDb()`. |
| `nethermind/src/Nethermind/Nethermind.Db/InMemoryColumnBatch.cs` | `InMemoryColumnWriteBatch<TKey>` — wraps per-column `InMemoryWriteBatch` instances |
| `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyColumnsDb.cs` | Read-only wrapper with `ClearTempChanges()` |
| `nethermind/src/Nethermind/Nethermind.Db.Rocks/ColumnsDb.cs` | RocksDB implementation — extends `DbOnTheRocks`, one `ColumnFamilyHandle` per enum value |
| `nethermind/src/Nethermind/Nethermind.Db.Rocks/ColumnDb.cs` | Single column within RocksDB — wraps a `ColumnFamilyHandle` |

### Usage (Consumers)

| File | Usage |
|------|-------|
| `nethermind/src/Nethermind/Nethermind.Blockchain/Receipts/PersistentReceiptStorage.cs` | Takes `IColumnsDb<ReceiptsColumns>`, gets 3 column DBs: `Default`, `Transactions`, `Blocks` |
| `nethermind/src/Nethermind/Nethermind.TxPool/BlobTxStorage.cs` | Takes `IColumnsDb<BlobTxsColumns>`, gets 3 column DBs: `FullBlobTxs`, `LightBlobTxs`, `ProcessedTxs` |

## Nethermind Architecture Summary

```
IColumnsDb<T> (interface)
  |-- GetColumnDb(T key) -> IDb           // Get DB for one column
  |-- ColumnKeys -> IEnumerable<T>        // List all column keys
  |-- StartWriteBatch() -> IColumnsWriteBatch<T>  // Cross-column atomic writes
  |-- CreateSnapshot() -> IColumnDbSnapshot<T>    // Point-in-time reads
  |-- CreateReadOnly(bool) -> IReadOnlyColumnDb<T>

IColumnsWriteBatch<T> (interface)
  |-- GetColumnBatch(T key) -> IWriteBatch   // Per-column batch

IColumnDbSnapshot<T> (interface)
  |-- GetColumn(T key) -> IReadOnlyKeyValueStore  // Per-column snapshot read

Implementations:
  MemColumnsDb<T>     -- Dictionary<T, MemDb>, lazy init
  ColumnsDb<T>        -- RocksDB with column families
  ReadOnlyColumnsDb<T> -- Read-only wrapper
```

Key design: `T` must be `struct, Enum`. Each enum value maps to a separate `IDb` instance. The `ColumnsDb<T>` shares a single underlying RocksDB instance but uses different `ColumnFamilyHandle` for each column.

## Existing Zig Implementation

### Current DB Layer (`client/db/`)

| File | What It Provides |
|------|-----------------|
| `client/db/adapter.zig` | Core types: `Database` (vtable), `WriteBatch`, `WriteBatchOp`, `DbName`, `DbValue`, `DbEntry`, `DbIterator`, `DbSnapshot`, `ReadFlags`, `WriteFlags`, `DbMetric`, `Error` |
| `client/db/memory.zig` | `MemoryDatabase` — in-memory `Database` impl with arena allocator |
| `client/db/null.zig` | `NullDb` — null object pattern |
| `client/db/read_only.zig` | `ReadOnlyDb` — read-only wrapper with in-memory overlay |
| `client/db/provider.zig` | `DbProvider` — `EnumArray(DbName, ?Database)` registry |
| `client/db/read_only_provider.zig` | `ReadOnlyDbProvider` — read-only wrapper for `DbProvider` |
| `client/db/rocksdb.zig` | `RocksDatabase` — stub (not yet implemented) |
| `client/db/root.zig` | Public API re-exports |

### What's Missing

1. **No `ColumnsDb` struct** — no way to have a single logical database with multiple named columns
2. **No `ReceiptsColumns` enum** — needed for receipt storage
3. **No `BlobTxsColumns` enum** — needed for blob transaction storage
4. **No `ColumnsWriteBatch`** — no cross-column atomic write batching
5. **No `ColumnDbSnapshot`** — no cross-column consistent snapshots

### Existing Patterns to Follow

- **Vtable dispatch**: `Database` uses `ptr: *anyopaque` + `vtable: *const VTable` (see `adapter.zig:342-613`)
- **Comptime init helper**: `Database.init(T, ptr, fns)` generates type-safe wrappers at comptime (see `adapter.zig:516-612`)
- **Arena allocation**: `MemoryDatabase` uses `std.heap.ArenaAllocator` for key/value ownership
- **WriteBatch**: Accumulates `WriteBatchOp` (put/del), commits atomically if backend supports it
- **EnumArray pattern**: `DbProvider` uses `std.EnumArray(DbName, ?Database)` for dense enum indexing

## Voltaire APIs

### No DB/Column Family Types in Voltaire

Voltaire does NOT provide raw key-value persistence or column family abstractions. It provides:

- **State management**: `StateManager`, `JournaledState`, `AccountCache`, `StorageCache`, `ContractCache` — all in-memory with journaling
- **RPC backend**: `ForkBackend` with `RpcClient` vtable for remote state fetching

### Relevant Voltaire Primitives

| File | Type | Relevance |
|------|------|-----------|
| `voltaire/.../primitives/Receipt/Receipt.zig` | `Receipt` struct | Receipt data type that will be stored in `ReceiptsColumns` |
| `voltaire/.../primitives/Blob/blob.zig` | `BlobTransaction`, `BlobSidecar`, `VersionedHash` | Blob tx types stored in `BlobTxsColumns` |
| `voltaire/.../primitives/State/state.zig` | `StorageKey` | Composite address+slot key |

### Conclusion on Voltaire

The `ColumnsDb`, `ReceiptsColumns`, and `BlobTxsColumns` types are **DB-layer concerns** that Voltaire intentionally does not provide. These should be implemented in `client/db/` as part of the XVI execution client's persistence layer.

## Spec References

### Receipts

Receipts are defined in the Ethereum execution specs. Each receipt contains:
- Status/root (pre/post-Byzantium)
- Cumulative gas used
- Logs bloom filter
- Logs array

The 3-column structure (Default, Transactions, Blocks) is a Nethermind optimization for indexing receipts by different keys, not an Ethereum spec requirement.

### Blob Transactions (EIP-4844)

Blob transactions are defined in EIP-4844 (Cancun hardfork). The 3-column structure (FullBlobTxs, LightBlobTxs, ProcessedTxs) is a Nethermind storage optimization:
- **FullBlobTxs**: Complete blob data (128KB per blob)
- **LightBlobTxs**: Transaction metadata without actual blob data
- **ProcessedTxs**: Transactions that have been included in blocks

### Relevant Spec Files

| Spec | Location |
|------|----------|
| EIP-4844 (Shard Blob Transactions) | `EIPs/EIPS/eip-4844.md` |
| Receipt encoding | `execution-specs/src/ethereum/forks/*/fork_types.py` (Receipt class) |
| State transition | `execution-specs/src/ethereum/forks/*/fork.py` (receipt generation in `apply_body`) |

## Implementation Plan

### New Files to Create

1. **`client/db/columns.zig`** — Generic `ColumnsDb(T)` struct
2. **`client/db/columns.zig`** — Also contains `ColumnsWriteBatch(T)` and `ColumnDbSnapshot(T)`

### New Enums (in `client/db/columns.zig` or separate files)

1. **`ReceiptsColumns`** — `{ default, transactions, blocks }`
2. **`BlobTxsColumns`** — `{ full_blob_txs, light_blob_txs, processed_txs }`

### Key Design Decisions

1. **Use `std.EnumArray(T, Database)`** for the column mapping (dense, no heap allocation for the mapping itself)
2. **Memory implementation first**: `MemColumnsDb(T)` wrapping N `MemoryDatabase` instances
3. **Reuse existing `Database` vtable**: Each column IS a `Database` — no new vtable needed for individual columns
4. **New vtable for `ColumnsDb`**: Needs its own interface for `getColumnDb()`, `startWriteBatch()`, `createSnapshot()`
5. **`ColumnsWriteBatch(T)`**: Wraps N `WriteBatch` instances, one per column
6. **`ColumnDbSnapshot(T)`**: Wraps N `DbSnapshot` instances, one per column

### Architecture Sketch

```zig
/// Generic column family database.
pub fn ColumnsDb(comptime T: type) type {
    return struct {
        const Self = @This();

        columns: std.EnumArray(T, Database),
        allocator: std.mem.Allocator,

        pub fn getColumnDb(self: *Self, key: T) Database { ... }
        pub fn columnKeys() []const T { ... }
        pub fn startWriteBatch(self: *Self, allocator: Allocator) ColumnsWriteBatch(T) { ... }
        pub fn createSnapshot(self: *Self) !ColumnDbSnapshot(T) { ... }
    };
}

/// In-memory implementation.
pub fn MemColumnsDb(comptime T: type) type {
    return struct {
        columns: std.EnumArray(T, MemoryDatabase),
        ...
    };
}
```

## Test Fixtures

No external test fixtures apply — this is an internal DB abstraction. Testing should cover:

1. `ColumnsDb` with `MemoryDatabase` backend per column
2. Cross-column write batches (atomic commit across columns)
3. Cross-column snapshots (consistent reads across columns)
4. `ReceiptsColumns` and `BlobTxsColumns` enum definitions
5. Column isolation (writes to one column don't affect others)

## Dependencies

- **Upstream**: `client/db/adapter.zig` (Database, WriteBatch, DbSnapshot, etc.)
- **Downstream**: Receipt storage (Phase 4), Blob transaction pool (Phase 5)
