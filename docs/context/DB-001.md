# DB-001: ReadOnlyDbFactory strict mode returns OutOfMemory instead of creating read-only DB

## Ticket Summary

`ReadOnlyDbFactory.createDbImpl` returns `error.OutOfMemory` when `overlay_allocator` is null (strict read-only mode) because it needs to heap-allocate `OwnedContext`. This makes the factory unusable in strict mode. Fix: accept a separate `context_allocator` parameter, or use the base factory's allocator, or restructure to avoid heap allocation for the context.

## Bug Location

**File**: `client/db/factory.zig`, lines 456–471 (`ReadOnlyDbFactory.createDbImpl`)

```zig
fn createDbImpl(self: *ReadOnlyDbFactory, settings: DbSettings) Error!OwnedDatabase {
    // 1. Create the base database via the base factory.
    const base_owned = try self.base.createDb(settings);
    errdefer base_owned.deinit();

    // We need an allocator for the context — use overlay_allocator if
    // available, otherwise this is an error (we need SOME allocator
    // to heap-allocate the context).
    const alloc = self.overlay_allocator orelse {
        // Strict read-only mode — still need an allocator for the context.
        // This is a design limitation: ReadOnlyDbFactory always needs
        // an allocator to heap-allocate the OwnedContext. For strict
        // read-only without an allocator, the caller should create
        // ReadOnlyDb directly instead of using the factory.
        return error.OutOfMemory;  // <-- BUG: always fails in strict mode
    };
    // ...
}
```

The code explicitly acknowledges the design limitation in comments but returns `error.OutOfMemory`, making `ReadOnlyDbFactory` unusable in strict read-only mode via the `DbFactory` vtable interface.

## Root Cause Analysis

`ReadOnlyDbFactory.init` takes `overlay_allocator: ?std.mem.Allocator`. In strict mode, this is `null`. But `createDbImpl` needs to heap-allocate an `OwnedContext` struct (which owns both the `ReadOnlyDb` wrapper and the `base_owned` database) — and it has no allocator to do so.

The `OwnedContext` struct:
```zig
const OwnedContext = struct {
    read_only: ReadOnlyDb,
    base_owned: OwnedDatabase,
    allocator: std.mem.Allocator,
};
```

## Nethermind Reference

### How Nethermind handles this

**Key insight**: Nethermind's `ReadOnlyDb` does NOT have a "strict mode that returns errors on writes." Instead, it ALWAYS creates a `MemDb` overlay — the `createInMemWriteStore` flag only controls whether `Set()` throws:

```csharp
// Nethermind.Db/ReadOnlyDb.cs
public class ReadOnlyDb(IDb wrappedDb, bool createInMemWriteStore) : IReadOnlyDb
{
    private readonly MemDb _memDb = new();  // ALWAYS created

    public void Set(ReadOnlySpan<byte> key, byte[]? value, WriteFlags flags = WriteFlags.None)
    {
        if (!createInMemWriteStore)
        {
            throw new InvalidOperationException($"This ReadOnlyDb did not expect any writes.");
        }
        _memDb.Set(keyBytes, value.ToArray(), writeFlags);
    }
}
```

Nethermind doesn't have a separate factory concept for "strict read-only" — it always wraps, always allocates the `MemDb`, and the flag only gates write methods.

**Nethermind's factory pattern** (`IDbFactory`):
- `IDbFactory.CreateDb(DbSettings)` → creates an `IDb`
- No separate "read-only factory" concept at the factory level
- `IDb.CreateReadOnly(bool)` is on the `IDb` interface itself (default impl creates `ReadOnlyDb`)
- `RpcDbFactory` wraps databases in `ReadOnlyDb(db, createInMemWriteStore: true)` — always with overlay

### Relevant Nethermind Files

| File | Purpose |
|------|---------|
| `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs` | ReadOnlyDb — always creates MemDb, flag only controls write behavior |
| `nethermind/src/Nethermind/Nethermind.Db/IReadOnlyDb.cs` | IReadOnlyDb interface (IDb + ClearTempChanges) |
| `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` | IDb.CreateReadOnly(bool) — default method creates ReadOnlyDb |
| `nethermind/src/Nethermind/Nethermind.Db/IDbFactory.cs` | IDbFactory — CreateDb, CreateColumnsDb, GetFullDbPath |
| `nethermind/src/Nethermind/Nethermind.Db/MemDbFactory.cs` | MemDbFactory — simple factory creating MemDb instances |
| `nethermind/src/Nethermind/Nethermind.Db.Rpc/RpcDbFactory.cs` | RpcDbFactory — wraps created dbs in ReadOnlyDb(db, true) |

## Existing Zig Implementation

### Files Directly Affected

| File | Relevance |
|------|-----------|
| `client/db/factory.zig` | **BUG LOCATION**: `ReadOnlyDbFactory.createDbImpl` lines 456-471 |
| `client/db/read_only.zig` | `ReadOnlyDb` — the wrapper being created; `init()` is zero-allocation for strict mode |
| `client/db/adapter.zig` | `OwnedDatabase` — the return type requiring heap-allocated context |

### Related Files (not directly affected)

| File | Relevance |
|------|-----------|
| `client/db/read_only_provider.zig` | `ReadOnlyDbProvider` — uses inline `Slot` array to avoid heap allocation (different pattern) |
| `client/db/memory.zig` | `MemoryDatabase` — used by overlay |
| `client/db/root.zig` | Re-exports all DB types |
| `client/db/provider.zig` | `DbProvider` — registry pattern |

### Key Design Observations

1. **`ReadOnlyDbProvider` solved this differently**: Uses a fixed `Slot` array (inline in the struct) indexed by `DbName` enum. `ReadOnlyDb` wrappers are created inline in slots — NO heap allocation needed even for strict mode. This is an elegant solution that doesn't apply to factories because factories return `OwnedDatabase` which requires heap allocation for the context.

2. **`ReadOnlyDb.init()` is zero-allocation**: The strict read-only `ReadOnlyDb` itself needs no allocator. The problem is only in the factory's `OwnedContext` wrapper that bundles the `ReadOnlyDb` + `base_owned` together for cleanup.

3. **`OwnedDatabase` pattern**: The factory must return `OwnedDatabase { .db, .deinit_ctx, .deinit_fn }`. The `deinit_ctx` is a heap-allocated struct that owns the cleanup context. This is where the allocation is unavoidable.

## Proposed Solutions

### Option A: Add a separate `context_allocator` parameter (Recommended)

```zig
pub const ReadOnlyDbFactory = struct {
    base: DbFactory,
    overlay_allocator: ?std.mem.Allocator,
    context_allocator: std.mem.Allocator,  // NEW: always available for OwnedContext

    pub fn init(base: DbFactory, overlay_allocator: ?std.mem.Allocator, context_allocator: std.mem.Allocator) ReadOnlyDbFactory {
        return .{
            .base = base,
            .overlay_allocator = overlay_allocator,
            .context_allocator = context_allocator,
        };
    }
    // ...
};
```

**Pros**: Clean separation of concerns. `context_allocator` is always available for OwnedContext heap allocation. `overlay_allocator` remains optional for the write overlay.

**Cons**: API change — callers must pass an extra allocator.

### Option B: Always require a non-null allocator, use a `strict_read_only: bool` flag

```zig
pub const ReadOnlyDbFactory = struct {
    base: DbFactory,
    allocator: std.mem.Allocator,  // Always available
    strict_read_only: bool,         // Controls overlay creation

    pub fn init(base: DbFactory, allocator: std.mem.Allocator, strict_read_only: bool) ReadOnlyDbFactory { ... }
};
```

**Pros**: Matches Nethermind's pattern more closely (allocator always available, flag controls write behavior). Simpler API.

**Cons**: Changes field naming.

### Option C: Use the base factory's allocator (if extractable)

This isn't possible because `DbFactory` is a type-erased vtable — there's no way to extract the allocator from the base factory through the interface.

### Option D: Restructure to avoid heap allocation

Not feasible because `OwnedDatabase` requires a `deinit_ctx: ?*anyopaque` which must point to heap-allocated memory to survive beyond the `createDbImpl` call.

## Spec References

N/A — This is an internal DB abstraction issue, not related to Ethereum specs.

## Voltaire APIs

N/A — Voltaire does not provide raw KV persistence or factory abstractions. The DB layer is entirely in `client/db/`.

## Test Fixtures

No external test fixtures. Testing should verify:

1. `ReadOnlyDbFactory` strict mode creates functional read-only databases
2. Writes return `error.StorageError` in strict mode
3. Reads delegate to base factory's database
4. `OwnedDatabase.deinit()` cleans up both wrapper and base
5. Multiple databases can be created from one strict factory
6. No memory leaks (use `std.testing.allocator`)

## Existing Tests

Current tests in `client/db/factory.zig` only test `ReadOnlyDbFactory` WITH overlay (lines 700-775). There are NO tests for strict read-only `ReadOnlyDbFactory` — because it would fail with `error.OutOfMemory`.
