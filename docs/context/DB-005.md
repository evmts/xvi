# DB-005: Add multi-get batch read API to Database vtable

## Summary

Add an optional `multi_get` method to the Database VTable, mirroring Nethermind's `IDb` indexer `this[byte[][] keys]` which maps to RocksDB's `MultiGet` for efficient batch reads. Default to `null` with sequential fallback (same pattern as `write_batch` and `merge`).

## Nethermind Reference

### IDb interface (authoritative)
- **File**: `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` (line 13)
- **Signature**: `KeyValuePair<byte[], byte[]?>[] this[byte[][] keys] { get; }`
- Returns an array of key-value pairs, one per input key. Value is nullable (null = key not found).

### DbOnTheRocks (RocksDB backend)
- **File**: `nethermind/src/Nethermind/Nethermind.Db.Rocks/DbOnTheRocks.cs` (lines 864-878)
- **Implementation**: Delegates directly to `_db.MultiGet(keys)` from RocksDbSharp
- Catches `RocksDbSharpException`, creates corruption marker if detected

### ColumnDb (RocksDB column families)
- **File**: `nethermind/src/Nethermind/Nethermind.Db.Rocks/ColumnDb.cs` (lines 66-74)
- **Implementation**: Creates array of `ColumnFamilyHandle[]`, fills with same column family, calls `_rocksDb.MultiGet(keys, columnFamilies)`

### MemDb (in-memory)
- **File**: `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs` (lines 67-79)
- **Implementation**: Sequential lookup: `keys.Select(k => new KeyValuePair(k, _db.GetValueOrDefault(k))).ToArray()`
- Increments `ReadsCount` by `keys.Length`

### NullDb (null object)
- **File**: `nethermind/src/Nethermind/Nethermind.Db/NullDb.cs` (line 34)
- **Implementation**: `keys.Select(k => new KeyValuePair(k, null)).ToArray()` — all values null

### ReadOnlyDb (overlay pattern)
- **File**: `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs` (lines 34-51)
- **Implementation**:
  1. Get results from wrapped DB: `result = wrappedDb[keys]`
  2. Get results from memory overlay: `memResult = _memDb[keys]`
  3. Merge: for each key, if `memResult[i].Value is not null`, use overlay value instead
  - This is the overlay precedence pattern (overlay wins over wrapped)

### Other implementations
- **CompressingDb**: `throw new NotImplementedException()` (not implemented)
- **FullPruningDb**: Delegates to current DB
- **SimpleFilePublicKeyDb**: Dictionary-based sequential lookup

## Existing Zig Implementation (files to modify)

### Core vtable and types
- **`client/db/adapter.zig`** — `Database.VTable` struct, `Database.init()` comptime helper, `DbValue` type, `test_vtable()` helper
  - Add optional `multi_get` field to VTable (like `write_batch` and `merge`)
  - Add `multi_get` convenience method on `Database`
  - Add `supports_multi_get` method on `Database`
  - Update `Database.init()` comptime helper to handle `multi_get`
  - Update `test_vtable()` to accept optional `multi_get`

### Backend implementations (need multi_get support)
- **`client/db/memory.zig`** — `MemoryDatabase` — implement sequential multi_get (like Nethermind MemDb)
- **`client/db/null.zig`** — `NullDb` — implement multi_get returning all nulls
- **`client/db/read_only.zig`** — `ReadOnlyDb` — implement overlay merge pattern (like Nethermind ReadOnlyDb)
- **`client/db/rocksdb.zig`** — `RocksDatabase` — stub returning errors (like all other ops)
- **`client/db/columns.zig`** — `ColumnsDb`, `MemColumnsDb`, `ReadOnlyColumnsDb` — may need multi_get pass-through

### Re-exports
- **`client/db/root.zig`** — No changes needed (re-exports types from adapter.zig)

## Design Decisions

### Return type
Nethermind returns `KeyValuePair<byte[], byte[]?>[]` — an allocated array of key-value pairs.

For Zig, the signature should be:
```zig
multi_get: ?*const fn (ptr: *anyopaque, keys: []const []const u8, flags: ReadFlags) Error![]?DbValue = null,
```

**Key considerations:**
- Returns `[]?DbValue` — a caller-owned slice of optional DbValues (null = not found)
- The returned slice length MUST equal `keys.len` (1:1 correspondence)
- Caller must free the returned slice AND release each non-null DbValue
- Allocator needed: the vtable fn must somehow allocate the result slice. Options:
  1. Pass allocator as parameter (breaks vtable uniformity)
  2. Use the backend's internal allocator (memory.zig uses arena)
  3. Caller provides output buffer (avoids allocation entirely)

**Recommended approach**: Option 3 — caller-provided output buffer:
```zig
multi_get: ?*const fn (ptr: *anyopaque, keys: []const []const u8, results: []?DbValue, flags: ReadFlags) Error!void = null,
```
- `results.len` must equal `keys.len` (caller ensures this)
- Backend fills `results[i]` with the value for `keys[i]` (null if not found)
- No allocation in the vtable call — caller manages the buffer
- This is more idiomatic Zig (avoid hidden allocations)

### Fallback behavior
When `multi_get` is null, `Database.multi_get()` convenience method falls back to sequential `get()` calls (same pattern as `write_batch` falling back to sequential puts).

### Pattern precedent
The optional vtable slot pattern is already established by:
- `write_batch: ?*const fn(...)` — defaults to null, sequential fallback
- `merge: ?*const fn(...)` — defaults to null, returns UnsupportedOperation

## Voltaire Primitives

No new Voltaire primitives are needed for this ticket. The DB abstraction layer uses:
- `[]const u8` for keys/values (raw byte slices)
- `DbValue` (defined in adapter.zig) for borrowed value references
- These are internal DB types, not Ethereum domain types

## Spec References

Phase 0 (DB Abstraction) has no external Ethereum specs — this is an internal abstraction layer. The design is driven by:
1. Nethermind's `IDb` interface (architecture reference)
2. RocksDB's `MultiGet` API (performance motivation)
3. The existing optional vtable slot pattern in adapter.zig

## Test Fixtures

No external test fixtures — unit tests only. Tests should cover:
1. `supports_multi_get()` reports false when absent
2. `supports_multi_get()` reports true when present
3. Sequential fallback when `multi_get` is null
4. Direct vtable dispatch when `multi_get` is provided
5. `MemoryDatabase` multi_get — found and missing keys
6. `NullDb` multi_get — all results null
7. `ReadOnlyDb` multi_get — overlay precedence over wrapped
8. `Database.init()` with and without `multi_get`
9. Error propagation (StorageError from backend)
10. Empty keys slice (edge case)

## Implementation Order

1. Add `multi_get` optional vtable slot to `Database.VTable` in adapter.zig
2. Add `multi_get()`, `multi_get_with_flags()`, and `supports_multi_get()` convenience methods to `Database`
3. Update `Database.init()` comptime helper to handle `multi_get`
4. Update `test_vtable()` helper to accept optional `multi_get`
5. Add unit tests in adapter.zig
6. Implement in `MemoryDatabase` (memory.zig)
7. Implement in `NullDb` (null.zig)
8. Implement in `ReadOnlyDb` (read_only.zig) — overlay merge pattern
9. Implement stub in `RocksDatabase` (rocksdb.zig)
10. Update `ColumnsDb` if needed (columns.zig)

## Files Summary

| File | Role | Action |
|------|------|--------|
| `client/db/adapter.zig` | VTable + Database type | Add multi_get vtable slot, convenience methods, comptime helper |
| `client/db/memory.zig` | MemoryDatabase | Implement sequential multi_get |
| `client/db/null.zig` | NullDb | Implement all-null multi_get |
| `client/db/read_only.zig` | ReadOnlyDb | Implement overlay merge multi_get |
| `client/db/rocksdb.zig` | RocksDatabase stub | Add error-returning multi_get |
| `client/db/columns.zig` | ColumnsDb | Pass-through multi_get if needed |
| `client/db/root.zig` | Re-exports | No changes needed |
| `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` | Reference | Authoritative interface |
| `nethermind/src/Nethermind/Nethermind.Db.Rocks/DbOnTheRocks.cs` | Reference | RocksDB MultiGet impl |
| `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs` | Reference | Sequential multi_get |
| `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs` | Reference | Overlay merge pattern |
| `nethermind/src/Nethermind/Nethermind.Db/NullDb.cs` | Reference | Null multi_get |
