# DB-006: Sorted View / Range Query Support

## Summary

Add `ISortedKeyValueStore` parity to the Guillotine DB abstraction layer. Nethermind provides `ISortedKeyValueStore` with `FirstKey`, `LastKey`, and `GetViewBetween(firstKey, lastKey)` for efficient range queries via RocksDB iterator bounds. This is needed for snap sync state enumeration, trie pruning (CommitSetQueue), and state inspection.

## Category

Phase 0: DB Abstraction Layer (`phase-0-db`)

## PRD Reference

- `prd/GUILLOTINE_CLIENT_PLAN.md` — Phase 0 section (lines 14-28)
- Phase 0 is "internal abstraction" with no external test fixtures
- Reference: `nethermind/src/Nethermind/Nethermind.Db/`

## Ethereum Specs

- `prd/ETHEREUM_SPECS_REFERENCE.md` — Phase 0 specs: "N/A (internal abstraction)"
- `devp2p/caps/snap.md` — The snap/1 protocol requires contiguous range retrieval of accounts and storage slots in state trie iteration order. This is the primary consumer of sorted/range query support. The protocol downloads "contiguous segment of accounts from the Ethereum state trie, or a contiguous segment of storage slots from one particular storage trie."
- No EIP directly mandates sorted DB access, but snap sync (Phase 9) depends on it.

## Test Suite Findings

From `docs/test-suite-findings.md`:
- Phase 0 has 165 passing unit tests across 10 modules
- No external test suite for Phase 0 (internal abstraction)
- RocksDB backend is still a stub (returns `error.StorageError`)
- `zig build test-db` blocked by Voltaire wallycore build issue; tests pass via direct `zig test`

## Nethermind Reference Files

### Core Interface — `ISortedKeyValueStore`
**File**: `nethermind/src/Nethermind/Nethermind.Core/IKeyValueStore.cs` (lines 120-179)

```csharp
public interface ISortedKeyValueStore : IReadOnlyKeyValueStore
{
    byte[]? FirstKey { get; }
    byte[]? LastKey { get; }
    ISortedView GetViewBetween(ReadOnlySpan<byte> firstKeyInclusive, ReadOnlySpan<byte> lastKeyExclusive);
}

public interface ISortedView : IDisposable
{
    public bool StartBefore(ReadOnlySpan<byte> value);
    public bool MoveNext();
    public ReadOnlySpan<byte> CurrentKey { get; }
    public ReadOnlySpan<byte> CurrentValue { get; }
}
```

Key design points:
- `ISortedKeyValueStore` extends `IReadOnlyKeyValueStore` (read-only, no writes)
- `ISortedView` is `IDisposable` — must free iterator resources
- `GetViewBetween` uses **inclusive lower bound, exclusive upper bound**
- `StartBefore(value)` seeks to the position before `value` (for reverse iteration start)
- `MoveNext()` advances forward; first call seeks to first entry

### RocksDB Implementation — `RocksDbReader`
**File**: `nethermind/src/Nethermind/Nethermind.Db.Rocks/RocksDbReader.cs` (lines 81-121)

- `FirstKey`: Creates iterator, `SeekToFirst()`, returns key if `Valid()`
- `LastKey`: Creates iterator, `SeekToLast()`, returns key if `Valid()`
- `GetViewBetween`: Creates `ReadOptions` with `iterate_lower_bound` and `iterate_upper_bound` set via native RocksDB API, then creates a `RocksdbSortedView`

### RocksDB Sorted View — `RocksdbSortedView`
**File**: `nethermind/src/Nethermind/Nethermind.Db.Rocks/RocksdbSortedView.cs` (63 lines)

- Wraps a RocksDB `Iterator` with lower/upper bound memory
- `StartBefore(value)`: calls `iterator.SeekForPrev(value)`, can only be called once before iteration starts
- `MoveNext()`: On first call, `SeekToFirst()`; subsequent calls, `iterator.Next()`; returns `iterator.Valid()`
- `CurrentKey` / `CurrentValue`: delegates to `iterator.GetKeySpan()` / `iterator.GetValueSpan()`
- `Dispose()`: disposes iterator and frees allocated lower/upper bound memory

### DbOnTheRocks — `ISortedKeyValueStore` Implementation
**File**: `nethermind/src/Nethermind/Nethermind.Db.Rocks/DbOnTheRocks.cs` (lines 1870-1912)

- `DbOnTheRocks` implements `ISortedKeyValueStore` directly
- `GetViewBetween` allocates native memory for bounds, sets them on `ReadOptions`, creates iterator + `RocksdbSortedView`

### ColumnDb — `ISortedKeyValueStore` Implementation
**File**: `nethermind/src/Nethermind/Nethermind.Db.Rocks/ColumnDb.cs` (lines 138-159)

- Delegates `FirstKey`, `LastKey`, `GetViewBetween` to the main `DbOnTheRocks` with column family handle

### Consumers of ISortedKeyValueStore

1. **CommitSetQueue (Trie Pruning)**: `nethermind/src/Nethermind/Nethermind.Trie/Pruning/CommitSetQueue.cs`
   - Uses `SortedSet<BlockCommitSet>.GetViewBetween()` for block-number range queries
   - Not directly using DB sorted view, but same pattern

2. **DbModule (DI Registration)**: `nethermind/src/Nethermind/Nethermind.Init/Modules/DbModule.cs`
   - Registers `ISortedKeyValueStore` as a keyed adapter from `IKeyValueStore`
   - Validates at startup that the DB instance implements `ISortedKeyValueStore`

3. **DbOnTheRocksTests**: `nethermind/src/Nethermind/Nethermind.Db.Test/DbOnTheRocksTests.cs` (lines 491-532)
   - `IteratorWorks()` test:
     - Inserts 3 entries `[0,0,0]`, `[1,1,1]`, `[2,2,2]`
     - Verifies `FirstKey == [0,0,0]`, `LastKey == [2,2,2]`
     - Calls `GetViewBetween([0], [9])` and iterates all 3 entries in order
     - Also tests sorted view through snapshots

## Existing Zig Implementation

### Current DB Adapter — `client/db/adapter.zig`
- **`Database`** struct with vtable: `get`, `put`, `delete`, `contains`, `iterator`, `snapshot`, `flush`, `clear`, `compact`, `gather_metric`, optional `write_batch`, `merge`, `multi_get`
- **`DbIterator`**: type-erased iterator with `next() -> ?DbEntry` and `deinit()`
- **`DbSnapshot`**: type-erased snapshot with `get`, `contains`, optional `iterator`, `deinit`
- **`DbEntry`**: `{ key: DbValue, value: DbValue }`
- **`DbValue`**: `{ bytes: []const u8, release_ctx, release_fn }`
- Already has `ReadFlags` (with `hint_read_ahead`) and `WriteFlags`
- **No sorted view / range query support currently exists**

### Current Iterator Support — `client/db/memory.zig`
- `make_iterator(ordered: bool)`: When `ordered=true`, collects all entries, sorts by `Bytes.compare`, returns `OrderedIterator`
- `OrderedIterator`: pre-sorted slice of `DbEntry`, iterates with index
- `MemoryIterator`: unordered hash map iteration
- **No range filtering — always iterates entire database**

### All DB Files
- `client/db/adapter.zig` — Core types (Database, DbIterator, DbSnapshot, WriteBatch, etc.)
- `client/db/memory.zig` — MemoryDatabase (in-memory backend)
- `client/db/null.zig` — NullDb (null object pattern)
- `client/db/rocksdb.zig` — RocksDatabase stub
- `client/db/read_only.zig` — ReadOnlyDb overlay
- `client/db/columns.zig` — ColumnsDb (column family support)
- `client/db/provider.zig` — DbProvider registry
- `client/db/read_only_provider.zig` — ReadOnlyDbProvider
- `client/db/factory.zig` — DbFactory (MemDbFactory, NullDbFactory, etc.)
- `client/db/root.zig` — Public re-exports
- `client/db/byte_slice_context.zig` — HashMap context for byte slices

## Voltaire APIs

- **No DB or sorted iterator primitives in Voltaire** — Voltaire provides state-manager types (`StateManager`, `JournaledState`, `StateCache`) but no raw KV persistence or sorted iteration interfaces. The DB abstraction layer is intentionally outside Voltaire's scope.
- `voltaire/packages/voltaire-zig/src/state-manager/StateManager.zig` — Uses `iterator` for internal snapshot cleanup but not for sorted DB access
- `voltaire/packages/voltaire-zig/src/primitives/` — Provides `Bytes.compare` (used by our existing ordered iterator sort)

## Design Approach

### Option A: Add to Database VTable (Nethermind's approach)
Add `first_key`, `last_key`, `sorted_view` to `Database.VTable` as optional fields (like `merge` and `multi_get`). Pros: single interface. Cons: bloats vtable for backends that don't support it.

### Option B: Separate SortedDatabase Interface (Recommended)
Create a `SortedDatabase` struct wrapping `Database` + sorted vtable, similar to how Nethermind has `ISortedKeyValueStore` as a separate interface from `IKeyValueStore`. This is cleaner but requires callers to know they have a sorted DB.

### Option C: Add sorted_view as optional VTable entries
Add `first_key`, `last_key`, `get_view_between` as optional nullable vtable entries on `Database.VTable` (same pattern as `merge`, `multi_get`, `write_batch`). Add `supports_sorted_view()` method. This is the simplest approach and matches the existing vtable extension pattern.

### Recommended: Option C
Matches the existing pattern of optional capabilities in the VTable (like `merge`, `multi_get`, `write_batch`). No new top-level types needed. Memory backends can implement it by sorting and filtering their ordered iterators. RocksDB backends will use native iterator bounds.

### New Types Needed

1. **`SortedView`** — Type-erased sorted view with vtable:
   - `start_before(value: []const u8) -> bool` — Seek to position before value
   - `move_next() -> ?DbEntry` — Advance to next entry (or first if not started)
   - `current_key() -> []const u8` — Current key
   - `current_value() -> []const u8` — Current value
   - `deinit()` — Release resources

2. **Optional VTable entries on `Database.VTable`**:
   - `first_key: ?*const fn(ptr: *anyopaque) Error!?DbValue`
   - `last_key: ?*const fn(ptr: *anyopaque) Error!?DbValue`
   - `get_view_between: ?*const fn(ptr: *anyopaque, first_key_inclusive: []const u8, last_key_exclusive: []const u8) Error!SortedView`

### Memory Backend Implementation
- `first_key`: Sort all keys, return minimum
- `last_key`: Sort all keys, return maximum
- `get_view_between`: Sort entries, filter to `[firstKey, lastKey)` range, return as `SortedView`

## Test Fixtures

- No external test fixtures (Phase 0 is internal abstraction)
- Must write comprehensive unit tests matching Nethermind's `DbOnTheRocksTests.IteratorWorks()`:
  - FirstKey / LastKey on empty DB → null
  - FirstKey / LastKey with entries → correct min/max
  - GetViewBetween with full range → all entries in order
  - GetViewBetween with partial range → correct subset
  - GetViewBetween with empty range → no entries
  - StartBefore semantics
  - SortedView through snapshots
  - NullDb returns UnsupportedOperation or null
  - MemoryDatabase sorted view correctness

## Dependencies

- Existing `client/db/adapter.zig` types (`Database`, `DbIterator`, `DbValue`, `DbEntry`)
- `client/db/byte_slice_context.zig` (for byte slice comparison)
- `primitives.Bytes.compare` (for sorting)
- No Voltaire dependencies needed for this ticket
