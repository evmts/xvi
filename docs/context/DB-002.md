# DB-002: Implement IDbFactory for Pluggable Database Creation

## Ticket Summary

Nethermind uses `IDbFactory` with `CreateDb(DbSettings)` and `CreateColumnsDb<T>(DbSettings)` to support diagnostic modes (MemDb mode, ReadOnly mode, RPC mode). Our code instantiates backends directly. Implement a `DbFactory` interface with `MemDbFactory`, `NullDbFactory`, and `ReadOnlyDbFactory` implementations. This enables test isolation and diagnostic modes.

## PRD Reference

**Source:** `prd/GUILLOTINE_CLIENT_PLAN.md` — Phase 0: DB Abstraction Layer

Phase 0 establishes the database abstraction layer. The DB factory pattern is part of this phase, enabling pluggable backends for different operational modes (production RocksDB, testing MemDb, diagnostics NullDb/ReadOnly).

**Source:** `prd/ETHEREUM_SPECS_REFERENCE.md` — Phase 0

- Specs: N/A (internal abstraction, not protocol-level)
- References: `nethermind/src/Nethermind/Nethermind.Db/`
- Tests: Unit tests only

## Nethermind Reference Architecture

### IDbFactory Interface

**File:** `nethermind/src/Nethermind/Nethermind.Db/IDbFactory.cs`

```csharp
public interface IDbFactory
{
    IDb CreateDb(DbSettings dbSettings);
    IColumnsDb<T> CreateColumnsDb<T>(DbSettings dbSettings) where T : struct, Enum;
    string GetFullDbPath(DbSettings dbSettings) => dbSettings.DbPath;
}
```

Key design points:
- Two methods: `CreateDb` (single-column) and `CreateColumnsDb<T>` (multi-column with generic enum key)
- `GetFullDbPath` has a default implementation returning `dbSettings.DbPath`
- Factory implementations control which backend type is used

### Factory Implementations

#### MemDbFactory
**File:** `nethermind/src/Nethermind/Nethermind.Db/MemDbFactory.cs`

```csharp
public class MemDbFactory : IDbFactory
{
    public IDb CreateDb(DbSettings dbSettings)
        => new MemDb(dbSettings.DbName);
    public IColumnsDb<T> CreateColumnsDb<T>(DbSettings dbSettings) where T : struct, Enum
        => new MemColumnsDb<T>(dbSettings.DbName);
}
```

- Simplest factory — creates in-memory databases for testing/diagnostic mode
- No configuration beyond the name

#### NullDbFactory (NullRocksDbFactory)
**File:** `nethermind/src/Nethermind/Nethermind.Db/NullRocksDbFactory.cs`

```csharp
public class NullDbFactory : IDbFactory
{
    private NullDbFactory() { }
    public static NullDbFactory Instance { get; } = new();
    public IDb CreateDb(DbSettings dbSettings)
        => throw new InvalidOperationException();
    public IColumnsDb<T> CreateColumnsDb<T>(DbSettings dbSettings) where T : struct, Enum
        => throw new InvalidOperationException();
}
```

- Singleton pattern
- Throws on any creation attempt — used as a sentinel/default when no real factory is configured
- Prevents accidental database creation in modes that shouldn't have persistence

#### RocksDbFactory
**File:** `nethermind/src/Nethermind/Nethermind.Db.Rocks/RocksDbFactory.cs`

```csharp
public class RocksDbFactory : IDbFactory
{
    private readonly IDbConfig _dbConfig;
    private readonly ILogManager _logManager;
    private readonly string _basePath;
    private readonly HyperClockCacheWrapper _sharedCache;
    private readonly IRocksDbConfigFactory _rocksDbConfigFactory;

    public IDb CreateDb(DbSettings dbSettings) =>
        new DbOnTheRocks(_basePath, dbSettings, _dbConfig, ...);
    public IColumnsDb<T> CreateColumnsDb<T>(DbSettings dbSettings) where T : struct, Enum =>
        new ColumnsDb<T>(_basePath, dbSettings, _dbConfig, ...);
    public string GetFullDbPath(DbSettings dbSettings)
        => DbOnTheRocks.GetFullDbPath(dbSettings.DbPath, _basePath);
}
```

- Production factory — creates real RocksDB databases
- Holds shared configuration (base path, cache, logging)
- Overrides `GetFullDbPath` to resolve relative to base path

#### FullPruningInnerDbFactory (Wrapper)
**File:** `nethermind/src/Nethermind/Nethermind.Db/FullPruning/FullPruningInnerDbFactory.cs`

- Decorator pattern — wraps another `IDbFactory`
- Manages indexed subdirectories for full state pruning
- Delegates actual creation to the wrapped factory

### DbSettings
**File:** `nethermind/src/Nethermind/Nethermind.Db/RocksDbSettings.cs`

```csharp
public class DbSettings
{
    public string DbName { get; private set; }
    public string DbPath { get; private set; }
    public bool DeleteOnStart { get; set; }
    public bool CanDeleteFolder { get; set; } = true;
    public IMergeOperator? MergeOperator { get; set; }
    public Dictionary<string, IMergeOperator>? ColumnsMergeOperators { get; set; }
    public DbSettings Clone(string name, string path);
    public DbSettings Clone();
}
```

### Type Hierarchy (Nethermind)
```
IDbFactory
  ├── MemDbFactory          → creates MemDb / MemColumnsDb<T>
  ├── NullDbFactory          → throws on create (sentinel)
  ├── RocksDbFactory         → creates DbOnTheRocks / ColumnsDb<T>
  └── FullPruningInnerDbFactory → wraps another IDbFactory
```

## Existing XVI Implementation

### Current DB Module (`client/db/`)

The DB abstraction layer is already well-established:

| File | Type | Description |
|------|------|-------------|
| `client/db/adapter.zig` | `Database` | Type-erased vtable interface (IDb equivalent) |
| `client/db/adapter.zig` | `WriteBatch` | Batched write operations |
| `client/db/adapter.zig` | `DbName` | 15 standard partition names |
| `client/db/adapter.zig` | `DbMetric`, `DbValue`, etc. | Supporting types |
| `client/db/memory.zig` | `MemoryDatabase` | In-memory backend (MemDb equivalent) |
| `client/db/null.zig` | `NullDb` | Null object pattern |
| `client/db/read_only.zig` | `ReadOnlyDb` | Read-only wrapper with optional overlay |
| `client/db/rocksdb.zig` | `RocksDatabase` | RocksDB stub (not yet implemented) |
| `client/db/rocksdb.zig` | `DbSettings` | RocksDB configuration |
| `client/db/provider.zig` | `DbProvider` | DbName -> Database registry |
| `client/db/read_only_provider.zig` | `ReadOnlyDbProvider` | Read-only provider wrapper |
| `client/db/columns.zig` | `ColumnsDb(T)` | Comptime-generic column families |
| `client/db/columns.zig` | `MemColumnsDb(T)` | In-memory column families |
| `client/db/columns.zig` | `ReadOnlyColumnsDb(T)` | Read-only column families |
| `client/db/root.zig` | Module root | Re-exports all public types |

### What's Missing: DbFactory

Currently, backends are instantiated directly:
```zig
var mem = MemoryDatabase.init(allocator, .state);
var null_db = NullDb.init(.state);
var rocks = RocksDatabase.init(settings);
```

There is **no factory abstraction** that lets callers create databases without knowing the concrete backend type. The `DbProvider` is a registry (lookup by name), not a factory (create by settings).

### Existing Patterns to Follow

1. **Vtable pattern** (from `adapter.zig`): `Database` uses `ptr + vtable` type erasure
2. **Comptime init helper** (from `adapter.zig`): `Database.init(T, ptr, fns)` generates vtable wrappers
3. **Owned → Interface pattern**: Each backend has `.database()` returning non-owning `Database`
4. **Arena allocators**: Transaction-scoped memory, free at end
5. **Error unions**: All operations return `Error!T`, never `catch {}`

## Voltaire APIs

Voltaire provides higher-level state management that sits **above** the raw DB layer:

| File | Type | Description |
|------|------|-------------|
| `voltaire-zig/src/state-manager/StateManager.zig` | `StateManager` | High-level state API with snapshots |
| `voltaire-zig/src/state-manager/JournaledState.zig` | `JournaledState` | Dual-cache state orchestrator |
| `voltaire-zig/src/state-manager/StateCache.zig` | `AccountCache`, `StorageCache`, `ContractCache` | Per-type caching with journaling |
| `voltaire-zig/src/state-manager/ForkBackend.zig` | `ForkBackend` | Async remote fetcher |
| `voltaire-zig/src/blockchain/Blockchain.zig` | `Blockchain` | Block orchestrator |
| `voltaire-zig/src/blockchain/BlockStore.zig` | `BlockStore` | Local block storage |

Voltaire uses **pure in-memory storage** with journaling. It does NOT provide a raw KV persistence interface or factory pattern. The DB factory is XVI-specific infrastructure that sits below Voltaire.

## Design Recommendations

### Interface Design (Zig idiom)

The factory should follow the established vtable pattern from `adapter.zig`:

```zig
pub const DbFactory = struct {
    ptr: *anyopaque,
    vtable: *const VTable,

    pub const VTable = struct {
        create_db: *const fn (ptr: *anyopaque, settings: DbSettings) Error!OwnedDatabase,
        create_columns_db: ... // comptime generic requires different approach
    };
};
```

**Key challenge:** Nethermind's `CreateColumnsDb<T>` uses runtime generics. In Zig, `ColumnsDb(T)` is comptime-generic. Options:
1. Use `comptime` parameter on the factory method (but vtable can't have comptime params)
2. Return a type-erased columns db wrapper
3. Provide a comptime factory interface instead of a vtable

### Concrete Factories

1. **`MemDbFactory`** — Creates `MemoryDatabase` / `MemColumnsDb(T)` instances
2. **`NullDbFactory`** — Returns error on creation (sentinel pattern)
3. **`ReadOnlyDbFactory`** — Wraps another factory, returns `ReadOnlyDb` views

### Ownership Model

**Critical difference from current code:** The factory must manage ownership of created databases. Currently, callers own backends directly. A factory needs to track created instances for cleanup:

```zig
pub const OwnedDatabase = struct {
    db: Database,          // type-erased interface
    deinit_fn: *const fn() void,  // cleanup callback
};
```

Or use an arena that owns all created databases.

## Relevant File Paths

### Nethermind Reference
- `nethermind/src/Nethermind/Nethermind.Db/IDbFactory.cs`
- `nethermind/src/Nethermind/Nethermind.Db/MemDbFactory.cs`
- `nethermind/src/Nethermind/Nethermind.Db/NullRocksDbFactory.cs`
- `nethermind/src/Nethermind/Nethermind.Db.Rocks/RocksDbFactory.cs`
- `nethermind/src/Nethermind/Nethermind.Db/FullPruning/FullPruningInnerDbFactory.cs`
- `nethermind/src/Nethermind/Nethermind.Db/RocksDbSettings.cs`
- `nethermind/src/Nethermind/Nethermind.Db/IDb.cs`
- `nethermind/src/Nethermind/Nethermind.Db/IColumnsDb.cs`
- `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs`
- `nethermind/src/Nethermind/Nethermind.Db/NullDb.cs`
- `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs`
- `nethermind/src/Nethermind/Nethermind.Db/MemColumnsDb.cs`
- `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyColumnsDb.cs`

### XVI Existing Code (to modify/extend)
- `client/db/root.zig` — Add DbFactory exports
- `client/db/adapter.zig` — Core types (Database, DbSettings, etc.)
- `client/db/memory.zig` — MemoryDatabase (created by MemDbFactory)
- `client/db/null.zig` — NullDb (created by NullDbFactory or error sentinel)
- `client/db/read_only.zig` — ReadOnlyDb (created by ReadOnlyDbFactory)
- `client/db/rocksdb.zig` — DbSettings, RocksDatabase
- `client/db/columns.zig` — ColumnsDb(T), MemColumnsDb(T)
- `client/db/provider.zig` — DbProvider (potential consumer of factory)

### Voltaire (reference, not modified)
- `voltaire-zig/src/state-manager/StateManager.zig`
- `voltaire-zig/src/state-manager/JournaledState.zig`

## Test Strategy

- Unit tests for each factory implementation
- Verify MemDbFactory creates functional MemoryDatabase instances
- Verify NullDbFactory returns appropriate errors
- Verify ReadOnlyDbFactory wraps correctly with/without overlay
- Verify factory interface dispatches through vtable correctly
- Verify created databases can be used with DbProvider
- Memory leak tests (testing allocator)
- Test factory decorator pattern (wrapping factories)
