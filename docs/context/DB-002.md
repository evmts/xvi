# DB-002: Refactor ReadOnlyDb.database() and RocksDatabase.database() to Use Database.init()

## Ticket Summary

`ReadOnlyDb.database()` (read_only.zig:138-143) and `RocksDatabase.database()` (rocksdb.zig:114-119)
construct the `Database` vtable via raw `ptr + vtable` struct literals instead of using the type-safe
`Database.init()` comptime helper. This is inconsistent with `MemoryDatabase.database()` (memory.zig:107)
and `NullDb.database()` (null.zig:51) which already use the helper. Refactoring to use `Database.init()`
would provide compile-time type safety and consistency.

## Category

`phase-0-db` — DB Abstraction Layer (internal refactor)

## PRD Reference

- `prd/GUILLOTINE_CLIENT_PLAN.md` — Phase 0: DB Abstraction Layer (lines 14-28)
- `prd/ETHEREUM_SPECS_REFERENCE.md` — Phase 0: N/A (internal abstraction, no Ethereum spec)
- No external test fixtures needed (Phase 0 is "Unit tests only")

## Ethereum Specs

N/A — This is a pure internal code quality refactor. No Ethereum execution spec, EIP, or protocol
behavior is affected. The DB abstraction layer is not protocol-defined.

## Test Suite Findings

From `docs/test-suite-findings.md`:
- Phase 0 DB: **PASSING** — All 165 unit tests pass across 10 modules
- Tests run via `zig test --dep primitives -Mroot=client/db/root.zig ...` (build system has wallycore issue)
- ReadOnlyDb has 25 tests, RocksDatabase has 10 tests — all passing
- All tests use `std.testing.allocator` for leak detection

## The Current Inconsistency

### Files ALREADY using `Database.init()` (good):

**`client/db/memory.zig:106-119`** — MemoryDatabase:
```zig
pub fn database(self: *MemoryDatabase) Database {
    return Database.init(MemoryDatabase, self, .{
        .name = name_impl,
        .get = get_impl,
        .put = put_impl,
        .delete = delete_impl,
        .contains = contains_impl,
        .iterator = iterator_impl,
        .snapshot = snapshot_impl,
        .flush = flush_impl,
        .clear = clear_impl,
        .compact = compact_impl,
        .gather_metric = gather_metric_impl,
    });
}
```

**`client/db/null.zig:50-64`** — NullDb:
```zig
pub fn database(self: *NullDb) Database {
    return Database.init(NullDb, self, .{
        .name = name_impl,
        .get = get_impl,
        .put = put_impl,
        .delete = delete_impl,
        .contains = contains_impl,
        .iterator = iterator_impl,
        .snapshot = snapshot_impl,
        .flush = flush_impl,
        .clear = clear_impl,
        .compact = compact_impl,
        .gather_metric = gather_metric_impl,
    });
}
```

### Files NOT using `Database.init()` (to refactor):

**`client/db/read_only.zig:138-143`** — ReadOnlyDb:
```zig
pub fn database(self: *ReadOnlyDb) Database {
    return .{
        .ptr = @ptrCast(self),
        .vtable = &vtable,
    };
}
```

**`client/db/rocksdb.zig:114-119`** — RocksDatabase:
```zig
pub fn database(self: *RocksDatabase) Database {
    return .{
        .ptr = @ptrCast(self),
        .vtable = &vtable,
    };
}
```

## The `Database.init()` Helper

Defined at `client/db/adapter.zig:516-612`. It accepts:
1. `comptime T: type` — the concrete backend type
2. `ptr: *T` — pointer to the backend instance
3. `comptime fns: struct { ... }` — typed function pointers accepting `*T` instead of `*anyopaque`

It generates a Wrapper struct with vtable functions that do `@ptrCast(@alignCast(raw))` automatically,
eliminating manual casting in every vtable implementation function.

### Key Signature (adapter.zig:516-529):
```zig
pub fn init(comptime T: type, ptr: *T, comptime fns: struct {
    name: *const fn (self: *T) DbName,
    get: *const fn (self: *T, key: []const u8, flags: ReadFlags) Error!?DbValue,
    put: *const fn (self: *T, key: []const u8, value: ?[]const u8, flags: WriteFlags) Error!void,
    delete: *const fn (self: *T, key: []const u8, flags: WriteFlags) Error!void,
    contains: *const fn (self: *T, key: []const u8) Error!bool,
    iterator: *const fn (self: *T, ordered: bool) Error!DbIterator,
    snapshot: *const fn (self: *T) Error!DbSnapshot,
    flush: *const fn (self: *T, only_wal: bool) Error!void,
    clear: *const fn (self: *T) Error!void,
    compact: *const fn (self: *T) Error!void,
    gather_metric: *const fn (self: *T) Error!DbMetric,
    write_batch: ?*const fn (self: *T, ops: []const WriteBatchOp) Error!void = null,
}) Database
```

## What Changes Are Needed

### 1. Refactor `ReadOnlyDb.database()` (read_only.zig)

**Current (lines 138-143):** Raw `.ptr + .vtable` construction
**New:** Use `Database.init(ReadOnlyDb, self, .{ ... })`

**Important consideration:** ReadOnlyDb's vtable impl functions currently take `*anyopaque` and
manually cast to `*ReadOnlyDb`. After refactoring to use `Database.init()`, these functions must
be changed to take `*ReadOnlyDb` as the first parameter. This means:

- `name_impl(ptr: *anyopaque)` → `name_impl(self: *ReadOnlyDb)`
- `get_impl(ptr: *anyopaque, ...)` → `get_impl(self: *ReadOnlyDb, ...)`
- etc. for all 11 functions (lines 311-395)
- Remove the `const self: *ReadOnlyDb = @ptrCast(@alignCast(ptr));` line from each
- Remove the standalone `const vtable = Database.VTable{ ... }` declaration (lines 297-309)

### 2. Refactor `RocksDatabase.database()` (rocksdb.zig)

**Current (lines 114-119):** Raw `.ptr + .vtable` construction
**New:** Use `Database.init(RocksDatabase, self, .{ ... })`

Same pattern:
- Change all vtable impl functions from `*anyopaque` to `*RocksDatabase`
- Remove manual `@ptrCast/@alignCast` in functions that use the pointer
- Remove the standalone `const vtable = Database.VTable{ ... }` declaration (lines 123-135)

**Note:** Most RocksDatabase vtable functions don't use the `ptr` parameter at all (they return
`error.StorageError`). Only `name_impl` uses it. The refactored functions will take `*RocksDatabase`
as self but ignore it for most operations.

### 3. No changes needed to adapter.zig, memory.zig, or null.zig

These already use the `Database.init()` pattern correctly.

## Existing Tests (Regression Safety)

All existing tests continue to work unchanged because:
- The `Database` vtable interface contract doesn't change
- Only the internal wiring (how vtable functions are generated) changes
- All 25 ReadOnlyDb tests + 10 RocksDatabase tests serve as regression tests

### ReadOnlyDb tests (25 tests in read_only.zig):
- Strict read-only mode: get, get_with_flags, missing key, contains, put/delete error, vtable dispatch
- Write overlay mode: overlay put/get, precedence, clear_temp_changes, delete, contains, reusable
- Iterator/snapshot: merge overlay+wrapped, ordered unsupported, snapshot isolation
- Safety: wrapped db never modified, deinit frees memory

### RocksDatabase tests (10 tests in rocksdb.zig):
- Stub behavior: get/put/delete/contains all return StorageError
- Configuration: name/path accessible, multiple instances, DbSettings init/clone/clone_with

## Nethermind Reference

Not directly relevant — this is a Zig-specific refactor. Nethermind uses C# interfaces (IDb),
not vtable patterns. The vtable approach and comptime init helper are Zig idioms.

### Relevant Nethermind files (for architectural context only):
- `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` — Interface definition
- `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs` — ReadOnlyDb equivalent
- `nethermind/src/Nethermind/Nethermind.Db.Rocks/DbOnTheRocks.cs` — RocksDB backend

## Voltaire APIs

N/A — Voltaire does not provide raw KV persistence interfaces. The DB adapter layer sits
below Voltaire's state management. No Voltaire types or APIs are involved in this refactor.

## Related Prior Work

### `add-database-comptime-init` context (docs/context/add-database-comptime-init.md)
This earlier research context documented the full scope of adding `Database.init()` and refactoring
all 4 backends. The `Database.init()` helper was implemented in adapter.zig, and MemoryDatabase
and NullDb were already refactored. ReadOnlyDb and RocksDatabase were **not yet refactored** —
that's exactly what this ticket addresses.

## Files to Modify

| File | Change | Lines |
|------|--------|-------|
| `client/db/read_only.zig` | Refactor `database()` to use `Database.init()`, change vtable impl fn signatures from `*anyopaque` to `*ReadOnlyDb`, remove manual vtable decl | 138-143 (database), 297-395 (vtable impl) |
| `client/db/rocksdb.zig` | Refactor `database()` to use `Database.init()`, change vtable impl fn signatures from `*anyopaque` to `*RocksDatabase`, remove manual vtable decl | 114-119 (database), 123-185 (vtable impl) |

## Files Read-Only (reference):

| File | Purpose |
|------|---------|
| `client/db/adapter.zig` | `Database.init()` helper definition (lines 516-612) |
| `client/db/memory.zig` | Reference: how MemoryDatabase uses `Database.init()` (lines 106-119, 319-362) |
| `client/db/null.zig` | Reference: how NullDb uses `Database.init()` (lines 50-64, 73-152) |

## Risk Assessment

- **Very low risk** — Pure refactor, no behavioral changes
- All 35 existing tests (25 ReadOnlyDb + 10 RocksDatabase) serve as regression tests
- The pattern is already proven by MemoryDatabase and NullDb
- No Ethereum spec compliance impact
- No Voltaire API changes
- No new files created
