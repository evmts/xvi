# DB-003: Eliminate module-level `var` in null.zig

## Summary

`null.zig` lines 154-159 declare two module-level `var` values:
```zig
var empty_iterator = EmptyIterator{};
var null_snapshot = NullSnapshot{};
```

These exist **only** because `DbIterator.init()` and `DbSnapshot.init()` in `adapter.zig` accept `*T` (mutable pointer). Both `EmptyIterator` and `NullSnapshot` are zero-sized types with no mutable state, so the `var` is semantically incorrect and works around a limitation in the current API.

The fix: change `DbIterator.init()` and `DbSnapshot.init()` to accept `*const T`, then change `null.zig` to use `const`.

## Files to Modify

### Primary targets

1. **`client/db/adapter.zig`** — Lines 216-243 (`DbIterator.init`) and lines 277-319 (`DbSnapshot.init`)
   - Change `ptr: *T` → `ptr: *const T` in both `init` functions
   - Update the `Wrapper` functions inside each `init` to cast `*anyopaque` → `*const T` instead of `*T`
   - The `ptr` field on `DbIterator` and `DbSnapshot` structs is `*anyopaque` — this doesn't need to change (opaque pointer is neither const nor non-const)
   - The vtable function signatures (`next`, `deinit`, `get`, `contains`, `iterator`) also use `*anyopaque` — these don't change

2. **`client/db/null.zig`** — Lines 158-159
   - Change `var empty_iterator = EmptyIterator{};` → `const empty_iterator = EmptyIterator{};`
   - Change `var null_snapshot = NullSnapshot{};` → `const null_snapshot = NullSnapshot{};`

### Callers that pass `*T` to `DbIterator.init` / `DbSnapshot.init` (must verify compatibility)

3. **`client/db/memory.zig`** — Lines 245, 254 (`DbIterator.init`), line 274 (`DbSnapshot.init`)
   - Uses heap-allocated pointers (`allocator.create(...)`) which are `*T` (mutable)
   - Passing `*T` where `*const T` is expected is valid in Zig (coercion: mutable → const)
   - **No changes needed** — but verify compilation

4. **`client/db/read_only.zig`** — Line 352 (`DbIterator.init`), line 267 (`DbSnapshot.init`)
   - Same pattern as memory.zig — heap-allocated, mutable pointers passed in
   - `*T` → `*const T` coercion is automatic in Zig
   - **No changes needed** — but verify compilation

## Detailed Analysis of `DbIterator.init` (adapter.zig:216-243)

Current signature:
```zig
pub fn init(
    comptime T: type,
    ptr: *T,
    comptime next_fn: *const fn (ptr: *T) Error!?DbEntry,
    comptime deinit_fn: *const fn (ptr: *T) void,
) DbIterator
```

Proposed signature:
```zig
pub fn init(
    comptime T: type,
    ptr: *const T,
    comptime next_fn: *const fn (ptr: *const T) Error!?DbEntry,
    comptime deinit_fn: *const fn (ptr: *const T) void,
) DbIterator
```

**WAIT — this is WRONG.** The `MemoryIterator` and `OrderedIterator` in `memory.zig` **do** mutate through their pointer:
- `MemoryIterator.next()` calls `self.iter.next()` which advances the iterator state
- `OrderedIterator.next()` increments `self.index`
- `OrderedIterator.deinit()` frees memory through the allocator
- `MemoryIterator.deinit()` calls `self.allocator.destroy(self)`

So we **cannot** change the function pointer types to `*const T` — that would break `MemoryIterator` and `OrderedIterator` which need `*T` to mutate.

### Correct approach: Accept BOTH `*T` and `*const T`

In Zig, `*const T` coerces to `*anyopaque`, and `*T` also coerces to `*anyopaque`. The vtable stores `*anyopaque`, so both work at the type-erasure boundary.

The issue is specifically in the `ptr` parameter of `init()`. We need to:
1. Accept `*const T` (so null.zig can pass `&empty_iterator` where `empty_iterator` is `const`)
2. Still allow callers that pass `*T` (memory.zig, read_only.zig)
3. Keep the function pointer types as `*const fn (ptr: *T)` for those that need mutation

**Actually, the simplest correct approach**: Change `ptr` parameter from `*T` to `anytype` with a comptime check, OR use `@ptrCast` in the caller. But looking more carefully...

### Revised approach: Only change the `ptr` parameter, not the function pointer types

Looking at Zig's pointer coercion rules:
- `*T` implicitly coerces to `*const T` ✅
- `*const T` does NOT implicitly coerce to `*T` ❌

So if we change `ptr: *T` → `ptr: *const T`, callers passing `*T` still work. But the `Wrapper` functions cast `*anyopaque` → `*T` (for the function pointer callbacks), which need `*T` for mutation.

The key insight: **the pointer stored as `*anyopaque` doesn't carry const/non-const**. The `init` function just does `@ptrCast(ptr)` to `*anyopaque`. The `Wrapper` functions cast back to `*T` when calling the user-provided function pointers.

So the actual change is:
1. In `DbIterator.init`: change `ptr: *T` → `ptr: anytype` and add comptime validation that it's a pointer to `T`, OR change to `*const T` but keep the function pointer signatures as `*T` for backends that mutate.

**Simplest correct fix**: Since the `ptr` is immediately cast to `*anyopaque` and the function pointer types control what the callbacks receive, we can change the `ptr` parameter to accept `*const T` while keeping the callback signatures as `*T`. The `@ptrCast` from `*const T` → `*anyopaque` is valid. The `@ptrCast` from `*anyopaque` → `*T` in the Wrapper is the backend's responsibility (if the backend passed a const pointer but the callback expects mutable, that's a logic error in the backend, not the framework).

**BUT ACTUALLY** — this would be unsound. If null.zig passes a `*const EmptyIterator` (const pointer to const data), and the Wrapper casts it to `*EmptyIterator` (mutable), that's undefined behavior even if the callback doesn't actually mutate.

### Final correct approach

The safest approach that the ticket describes:

1. Change `DbIterator.init` and `DbSnapshot.init` to accept `*const T` for the pointer AND change the function pointer signatures to also take `*const T`.
2. For callers that need mutation (memory.zig, read_only.zig), the function pointer signatures must use `*T`. Since `*T` != `*const T` at the type level, these callers need their own `init` call with `*T`.

**ALTERNATIVE**: Make the `init` function generic over the pointer constness. The cleanest way in Zig is to keep `*T` but have null.zig use `@constCast` on the pointer. BUT `@constCast` on a truly const value is undefined behavior.

**ACTUALLY THE SIMPLEST**: The ticket says "Refactor DbIterator.init and DbSnapshot.init in adapter.zig to accept `*const T`". This means:
- Change `ptr: *T` → `ptr: *const T`
- Change callback signatures to take `*const T`
- For memory.zig and read_only.zig, the callbacks internally use `@constCast` since they know their data is actually mutable (heap-allocated)

**NO** — that's backwards. The better pattern:

Make TWO versions of init, or use `anytype` for the pointer. Looking at how Zig std does this... `std.sort.insertionSort` uses `anytype`. Let's use `anytype`:

```zig
pub fn init(
    comptime T: type,
    ptr: anytype, // accepts *T or *const T
    comptime next_fn: ...,
    comptime deinit_fn: ...,
) DbIterator
```

But then we need to verify the ptr type matches T at comptime.

### ACTUALLY — Re-reading the ticket more carefully

The ticket says: "Refactor DbIterator.init and DbSnapshot.init in adapter.zig to accept `*const T` for the pointer parameter"

For null.zig's EmptyIterator:
- `next()` doesn't mutate → can take `*const EmptyIterator`
- `deinit()` doesn't mutate → can take `*const EmptyIterator`

For memory.zig's MemoryIterator:
- `next()` DOES mutate → needs `*MemoryIterator`
- `deinit()` DOES mutate → needs `*MemoryIterator`

These are different `T` types with different constness requirements. The solution is likely to make `init` accept either `*T` or `*const T` for the pointer parameter. Since both coerce to `*anyopaque`, the stored pointer type doesn't matter.

**The real fix**: Change only the `ptr` parameter type to be more permissive (accept `*const T` in addition to `*T`), while keeping the callback function pointer types as they are (each backend defines its own). The simplest way: just change `ptr: *T` to use Zig's pointer coercion by accepting `*const T` (since `*T` coerces to `*const T`), and do `@ptrCast(@constCast(ptr))` to get `*anyopaque`.

Wait — in Zig, `@ptrCast` from `*const T` to `*anyopaque` should work directly since `*anyopaque` is a mutable opaque pointer. Let me verify...

Actually in Zig 0.13+, `*const T` cannot be directly cast to `*anyopaque` (which is mutable). You'd need `*const anyopaque`. So the `ptr` field in `DbIterator` would need to change to `*const anyopaque`, or we use `@constCast`.

### Implementation Plan

The cleanest approach (matching what the ticket asks):

1. **Change `DbIterator` struct's `ptr` field** from `*anyopaque` to `*const anyopaque`
2. **Change `DbIterator.init` signature** to accept `*const T` for ptr
3. **Change Wrapper functions** to cast `*const anyopaque` → `*const T` → (if needed) `@constCast` to get `*T`
4. Same for `DbSnapshot`
5. Update `DbIterator.next()` and `DbIterator.deinit()` to pass `*const anyopaque` through vtable
6. **Update VTable function signatures** to take `*const anyopaque` instead of `*anyopaque`
7. In the Wrapper, cast back: if the callback needs `*T`, use `@constCast(@ptrCast(@alignCast(raw)))`

This is getting complex. Let me look at what the simplest change would be.

**SIMPLEST**: Just change `ptr: *T` to `ptr: anytype` in `DbIterator.init` and `DbSnapshot.init`, add a comptime check, and cast to `*anyopaque` using `@ptrCast(@constCast(ptr))` when the pointer is const. This avoids changing the stored field type or vtable signatures.

## Nethermind Reference

- **`nethermind/src/Nethermind/Nethermind.Db/NullDb.cs`** — Singleton pattern, throws `NotSupportedException` on writes. Uses C#'s `IEnumerable<>` which is inherently read-only iteration. No pointer mutability concern in C#.

## Voltaire Reference

- No DB primitives in Voltaire (confirmed in adapter.zig docs: "Voltaire does not provide a raw KV persistence interface")

## Test Fixtures

- No external test fixtures for DB layer (Phase 0 is internal abstraction)
- All 9 existing NullDb tests in `client/db/null.zig` must continue passing
- All 23 MemoryDatabase tests in `client/db/memory.zig` must continue passing
- All 25 ReadOnlyDb tests in `client/db/read_only.zig` must continue passing
- All 30 adapter tests in `client/db/adapter.zig` must continue passing

## Spec References

- N/A — This is a pure code quality refactor with no Ethereum spec implications

## Key Files

| File | Path | Role |
|------|------|------|
| adapter.zig | `client/db/adapter.zig` | DbIterator.init (L216-243), DbSnapshot.init (L277-319) — PRIMARY CHANGE |
| null.zig | `client/db/null.zig` | EmptyIterator/NullSnapshot var → const (L158-159) — PRIMARY CHANGE |
| memory.zig | `client/db/memory.zig` | MemoryIterator/OrderedIterator/MemorySnapshot — VERIFY STILL COMPILES |
| read_only.zig | `client/db/read_only.zig` | ReadOnlyIterator/ReadOnlySnapshot — VERIFY STILL COMPILES |
| NullDb.cs | `nethermind/src/Nethermind/Nethermind.Db/NullDb.cs` | Nethermind reference |

## Risk Assessment

- **Low risk** — Pure internal refactor, no behavioral changes
- **Compilation impact** — Must verify all 5 callers of `DbIterator.init` and all 3 callers of `DbSnapshot.init` still compile
- **Zig pointer semantics** — Need to carefully handle `*T` vs `*const T` vs `*anyopaque` coercion rules in Zig 0.15
- **No spec impact** — No Ethereum behavior changes
