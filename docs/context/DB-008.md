# DB-008: Add explicit test for DbValue.release() on borrowed values is safe no-op

## Ticket Summary

**Title**: test(db): Add explicit test for DbValue.release() on borrowed values is safe no-op
**Category**: phase-0-db
**Problem**: `DbValue.borrowed()` creates a value with `release_fn=null`. While `release()` correctly checks for null before calling the function, there is no explicit test verifying this safety contract. Without an explicit test, a future refactor could remove the null check and introduce a null-pointer dereference.
**Goal**: Add a test that calls `DbValue.borrowed("hello").release()` and verifies it does not panic, documenting the contract and catching regressions.

---

## PRD Reference

**Phase**: Phase 0 — DB Abstraction Layer (`phase-0-db`)
**Location**: `prd/GUILLOTINE_CLIENT_PLAN.md` lines 14-28
**Specs**: N/A (internal abstraction) — unit tests only
**Nethermind reference**: `nethermind/src/Nethermind/Nethermind.Db/`

---

## Ethereum Specs

**Spec file**: `prd/ETHEREUM_SPECS_REFERENCE.md` lines 18-25
- Phase 0 DB: "Specs: N/A (internal abstraction)" — unit tests only
- No Ethereum spec governs the DB value lifecycle — this is purely an internal safety contract

---

## Test Suite Findings

**Location**: `docs/test-suite-findings.md`
- Phase 0 has 165 passing tests across 10 modules
- `adapter.zig` has 30 existing tests covering Database vtable, WriteBatch, DbName, OwnedDatabase, ReadFlags/WriteFlags
- No existing test explicitly verifies `DbValue.borrowed().release()` is a safe no-op
- Build system blocked by Voltaire wallycore issue; tests run via direct `zig test` invocation

---

## Nethermind Reference Implementation

### IDb.cs
**Path**: `nethermind/src/Nethermind/Nethermind.Db/IDb.cs`
- Nethermind uses `byte[]?` (nullable byte arrays) for DB values — no release/dispose pattern needed for managed GC memory
- `IDb : IDisposable` provides `Dispose()` at the database level, not per-value

### MemDb.cs
**Path**: `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs`
- Line 102: `public void Dispose() { }` — MemDb's Dispose is a no-op
- Line 106: `public unsafe void DangerousReleaseMemory(in ReadOnlySpan<byte> span) { }` — also a no-op for MemDb
- In C# with GC, borrowed values don't need explicit release — the Zig `DbValue.release()` is our Zig-idiomatic equivalent of this safety guarantee

### Key insight
Nethermind's GC automatically handles value lifetime. Our `DbValue` with optional release hook bridges this gap for Zig's manual memory management. The `borrowed()` constructor with `release_fn=null` is the Zig equivalent of returning a GC-managed `byte[]` reference — no cleanup needed. The test documents this contract.

---

## Voltaire APIs

No Voltaire primitives are involved. Voltaire does not have a `DbValue` type — the DB abstraction layer is internal to Guillotine.

**Confirmed non-existence**: Searched `/Users/williamcory/voltaire/packages/voltaire-zig/src/` for `DbValue` and `db.*value` — no relevant matches. The 3 matches found were in unrelated files (StorageProof, SSZ, curve parameters).

---

## Existing Implementation

### DbValue struct (adapter.zig lines 177-192)
**Path**: `client/db/adapter.zig`

```zig
/// Release callback for DB values owned by the backend.
pub const ReleaseFn = *const fn (ctx: ?*anyopaque, bytes: []const u8) void;

/// Borrowed DB value with optional release hook.
pub const DbValue = struct {
    bytes: []const u8,
    release_ctx: ?*anyopaque = null,
    release_fn: ?ReleaseFn = null,

    pub fn release(self: DbValue) void {
        if (self.release_fn) |func| {
            func(self.release_ctx, self.bytes);
        }
    }

    pub fn borrowed(bytes: []const u8) DbValue {
        return .{ .bytes = bytes };
    }
};
```

**Analysis**:
- `borrowed()` returns `DbValue{ .bytes = bytes }` with default `release_ctx = null` and `release_fn = null`
- `release()` checks `self.release_fn` with `if` — only calls the function when non-null
- This null-check pattern is the safety contract that needs explicit test coverage
- Currently, `release()` is called extensively throughout tests on `DbValue.borrowed()` values (e.g., `memory.zig:592`, `read_only.zig:636`), but always as part of larger test scenarios — never as an isolated safety assertion

### DbEntry struct (adapter.zig lines 194-203)
**Path**: `client/db/adapter.zig`

```zig
pub const DbEntry = struct {
    key: DbValue,
    value: DbValue,

    pub fn release(self: DbEntry) void {
        self.key.release();
        self.value.release();
    }
};
```

**Analysis**: `DbEntry.release()` delegates to `DbValue.release()` for both key and value. Same safety contract applies — borrowed entries should also be safe to release.

### Where borrowed() is used
`DbValue.borrowed()` is used pervasively:
- `memory.zig`: `get_with_flags()`, `first_key_impl()`, `last_key_impl()`, iterators, sorted views
- `null.zig`: Not used (returns null, not borrowed values)
- `read_only.zig`: Not used directly (delegates to wrapped/overlay)
- `adapter.zig` tests: Multi-get tests use `DbValue.borrowed("val_a")` etc.
- All usages correctly call `.release()` on the result, relying on the null-check safety

---

## Implementation Strategy

### What to add
A single test in `client/db/adapter.zig` at the end of the existing test section:

```zig
test "DbValue: release on borrowed value is safe no-op" {
    const val = DbValue.borrowed("hello");
    val.release(); // should not panic — release_fn is null
    // Access bytes after release to confirm no corruption
    try std.testing.expectEqualStrings("hello", val.bytes);
}
```

### Optional additional test for DbEntry
```zig
test "DbEntry: release on borrowed entry is safe no-op" {
    const entry = DbEntry{
        .key = DbValue.borrowed("key"),
        .value = DbValue.borrowed("value"),
    };
    entry.release(); // should not panic
    try std.testing.expectEqualStrings("key", entry.key.bytes);
    try std.testing.expectEqualStrings("value", entry.value.bytes);
}
```

### Considerations
1. The test should be in `adapter.zig` since that's where `DbValue` is defined
2. No allocations needed — this is a pure stack test
3. Test verifies both safety (no panic) and stability (bytes accessible after release)
4. Adding to the existing adapter.zig test section maintains test co-location with the type definition

---

## Test Fixtures

No external test fixtures — Phase 0 DB is an internal abstraction with unit tests only.
Test should be added inline in `client/db/adapter.zig`.

---

## File Inventory

| File | Role |
|------|------|
| `client/db/adapter.zig` | **Target file** — contains `DbValue` struct definition (lines 177-192), add test here |
| `client/db/root.zig` | Re-exports `DbValue` as public API (line 69) |
| `client/db/memory.zig` | Heavy user of `DbValue.borrowed()` — reference for existing usage patterns |
| `client/db/null.zig` | Uses `DbValue` in type signatures but returns null, not borrowed values |
| `client/db/read_only.zig` | Delegates to wrapped/overlay, passes through `DbValue` |
| `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs` | Reference — `DangerousReleaseMemory` is a no-op for MemDb |
| `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` | Reference — `IDisposable` at DB level, not per-value |
