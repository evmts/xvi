# DB-007: Implement ordered iteration for ReadOnlyDb with overlay

## Ticket Summary

**Title**: feat(db): Implement ordered iteration for ReadOnlyDb with overlay
**Category**: phase-0-db
**Problem**: `ReadOnlyDb.iterator_impl` returns `error.UnsupportedOperation` when `ordered=true` and overlay is present (read_only.zig:349). Need a merge-sort iterator that yields entries from both overlay and wrapped DB in key order, deduplicating with overlay precedence.
**Use Case**: Snap sync state enumeration through read-only views — the snap protocol requires contiguous, ordered iteration over state for serving `GetAccountRange` / `GetStorageRanges` messages.

---

## PRD Reference

**Phase**: Phase 0 — DB Abstraction Layer (`phase-0-db`)
**Location**: `prd/GUILLOTINE_CLIENT_PLAN.md` lines 14-28
**Specs**: N/A (internal abstraction), but the feature is needed for Phase 9 (Sync) snap protocol support.
**Nethermind reference**: `nethermind/src/Nethermind/Nethermind.Db/`

---

## Ethereum Specs

**Spec file**: `prd/ETHEREUM_SPECS_REFERENCE.md` lines 18-25
- Phase 0 DB: "Specs: N/A (internal abstraction)" — unit tests only
- Phase 9 Sync: Depends on `devp2p/caps/snap.md` — snap sync requires ordered iteration

**Snap Protocol** (`devp2p/caps/snap.md`):
- `GetAccountRange` (0x00): Requests contiguous range of accounts in trie iteration order (sorted by hash)
- `GetStorageRanges` (0x02): Requests contiguous storage slot ranges
- The snap protocol requires "fast iterable access to the state" — serving nodes must iterate state linearly in key order
- Sort order is "the same as the state trie iteration order" (lexicographic byte comparison of key hashes)

---

## Test Suite Findings

**Location**: `docs/test-suite-findings.md`
- Phase 0 has 165 passing tests, including 25 for `read_only.zig`
- There is already a test `"ReadOnlyDb: iterator ordered is unsupported with overlay"` (line 909-918) that asserts `error.UnsupportedOperation` — this test must be replaced
- Build system blocked by Voltaire wallycore issue; tests run via direct `zig test` invocation

---

## Nethermind Reference Implementation

### ReadOnlyDb.cs
**Path**: `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs`

Key observations:
- Line 53: `GetAll(bool ordered = false) => _memDb.GetAll().Union(wrappedDb.GetAll())`
- Nethermind's `ReadOnlyDb.GetAll()` uses LINQ `.Union()` which performs set deduplication (memDb values take precedence since they appear first)
- The `ordered` parameter is **passed through to MemDb.GetAll()** which uses `_db.OrderBy(kvp => kvp.Key, Bytes.Comparer)` for ordered iteration
- **Critical**: Nethermind does NOT do a proper merge-sort — it relies on LINQ `Union` deduplication. But for our ordered case, we need proper merge-sort to maintain key order while deduplicating.

### MemDb.cs
**Path**: `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs`
- Line 89-93: `GetAll(ordered)` returns `ordered ? OrderedDb : _db`
- Line 140: `OrderedDb => _db.OrderBy(kvp => kvp.Key, Bytes.Comparer)` — sorts by key using `Bytes.Comparer` (lexicographic byte comparison)

### IDb.cs
**Path**: `nethermind/src/Nethermind/Nethermind.Db/IDb.cs`
- `GetAll(bool ordered = false)` — iterator with optional ordering
- `GetAllKeys(bool ordered = false)` — key-only iterator

### IReadOnlyDb.cs
**Path**: `nethermind/src/Nethermind/Nethermind.Db/IReadOnlyDb.cs`
- `ClearTempChanges()` — only additional method on read-only interface

---

## Voltaire APIs

### Bytes.compare
**Path**: `/Users/williamcory/voltaire/packages/voltaire-zig/src/primitives/Bytes/Bytes.zig:192`
```zig
pub fn compare(a: []const u8, b: []const u8) i8
```
Returns: -1 if a < b, 0 if equal, 1 if a > b. Lexicographic byte comparison.
**Already used** in `memory.zig:db_entry_less_than` for sorting entries.

### Bytes.equals
**Path**: `/Users/williamcory/voltaire/packages/voltaire-zig/src/primitives/Bytes/Bytes.zig`
Used in `ByteSliceContext.eql` for hash map key comparison.

No Voltaire DB-specific primitives exist — the DB layer is internal to Guillotine.

---

## Existing Implementation

### read_only.zig (target file)
**Path**: `client/db/read_only.zig`

#### Current iterator_impl (lines 347-365):
```zig
fn iterator_impl(self: *ReadOnlyDb, ordered: bool) Error!DbIterator {
    if (self.overlay) |ov| {
        if (ordered) return error.UnsupportedOperation;  // <-- THE BUG
        // ... unordered merge iterator follows
    }
    return self.wrapped.iterator(ordered);
}
```

#### Existing ReadOnlyIterator (unordered, lines 215-259):
- Two-phase approach: yields all overlay entries, then wrapped entries
- Uses `seen` hash set to skip wrapped entries that exist in overlay
- Does NOT maintain key order

#### What needs to change:
1. Add a new `MergeSortIterator` struct that:
   - Gets ordered iterators from both overlay and wrapped
   - Performs merge-sort: compare current entries from both, yield the smaller key
   - When keys are equal, yield overlay value (overlay precedence) and skip wrapped
2. Remove the `if (ordered) return error.UnsupportedOperation` guard
3. Update test `"ReadOnlyDb: iterator ordered is unsupported with overlay"` to verify ordered iteration works

### adapter.zig (interface definitions)
**Path**: `client/db/adapter.zig`
- `DbIterator` (line 206): Type-erased iterator with `next()` → `?DbEntry` and `deinit()`
- `DbEntry` (line 195): `{ key: DbValue, value: DbValue }` with `release()`
- `Database.iterator(ordered: bool)` (line 629): Returns `DbIterator`

### memory.zig (MemoryDatabase ordered iterator reference)
**Path**: `client/db/memory.zig`
- `OrderedIterator` (line 217-233): Pre-sorts all entries into a slice, iterates sequentially
- `db_entry_less_than` (line 337-339): Sort comparator using `Bytes.compare`
- `make_iterator(ordered=true)` (lines 341-363): Collects all entries, heap-sorts, returns `OrderedIterator`

### byte_slice_context.zig
**Path**: `client/db/byte_slice_context.zig`
- `ByteSliceContext`: Hash/equality for byte slices (used by `ReadOnlyIterator.seen` set)

---

## Implementation Strategy

### Approach: Merge-Sort Iterator with Two Ordered Sub-Iterators

```
MergeSortIterator {
    overlay_iter: DbIterator,     // ordered iterator from overlay
    wrapped_iter: DbIterator,     // ordered iterator from wrapped
    overlay_current: ?DbEntry,    // buffered lookahead for overlay
    wrapped_current: ?DbEntry,    // buffered lookahead for wrapped
    allocator: Allocator,
}
```

**Algorithm**:
1. On construction, get `ordered=true` iterators from both overlay and wrapped
2. Pre-fetch first entry from each (lookahead)
3. On each `next()`:
   - If both have entries: compare keys with `Bytes.compare`
     - overlay < wrapped: yield overlay, advance overlay
     - wrapped < overlay: yield wrapped, advance wrapped
     - equal: yield overlay (precedence), advance both, release wrapped's duplicate
   - If only one has entries: yield from that one
   - If neither: return null (exhausted)
4. On `deinit`: clean up both sub-iterators, release any buffered entries

**Why merge-sort**: Both sub-iterators are already sorted (MemoryDatabase's `OrderedIterator` sorts entries). Merge is O(n+m) with no extra allocation beyond the iterator struct itself.

**Precedence rule**: Overlay values always win over wrapped values for the same key (consistent with `get()` behavior and Nethermind's `.Union()` semantics).

### Changes Required:
1. **Add `MergeSortIterator` struct** in `read_only.zig` (~40 lines)
2. **Modify `iterator_impl`**: When overlay present and `ordered=true`, create `MergeSortIterator`
3. **Update/replace test**: Change "iterator ordered is unsupported with overlay" to verify correct ordered behavior
4. **Add new tests**: Ordered iteration with overlay precedence, empty overlay/wrapped, all-overlay, all-wrapped

### Performance Considerations:
- The merge-sort approach is O(n+m) where n=overlay entries, m=wrapped entries
- No additional heap allocation beyond the iterator struct itself
- Both sub-iterators may allocate (MemoryDatabase's OrderedIterator allocates a sorted slice), but that's already the case for ordered iteration
- For large datasets, this is optimal — no need to merge into a single sorted array upfront

---

## Test Fixtures

No external test fixtures — Phase 0 DB is an internal abstraction with unit tests only.
Tests should be added inline in `read_only.zig`.

---

## File Inventory

| File | Role |
|------|------|
| `client/db/read_only.zig` | **Target file** — add MergeSortIterator, modify iterator_impl |
| `client/db/adapter.zig` | Interface definitions (DbIterator, DbEntry, Database) |
| `client/db/memory.zig` | Reference: OrderedIterator, db_entry_less_than comparator |
| `client/db/byte_slice_context.zig` | ByteSliceContext for hash maps |
| `nethermind/src/Nethermind/Nethermind.Db/ReadOnlyDb.cs` | Nethermind reference — GetAll uses Union() |
| `nethermind/src/Nethermind/Nethermind.Db/MemDb.cs` | Nethermind reference — OrderedDb uses Bytes.Comparer |
| `nethermind/src/Nethermind/Nethermind.Db/IDb.cs` | Nethermind interface with GetAll(ordered) |
| `voltaire/.../Bytes/Bytes.zig` | `Bytes.compare` for lexicographic comparison |
| `devp2p/caps/snap.md` | Snap protocol requiring ordered state iteration |
