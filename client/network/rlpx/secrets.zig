//! RLPx Handshake Secrets Derivation
//!
//! Implements the minimal, specification-accurate derivation of RLPx
//! session secrets from the ECIES ephemeral shared secret and the two
//! nonces exchanged during the auth/ack handshake.
//!
//! Spec reference: devp2p/rlpx.md
//!
//!   shared-secret = keccak256(ephemeral-key || keccak256(recipient-nonce || initiator-nonce))
//!   aes-secret    = keccak256(ephemeral-key || shared-secret)
//!   mac-secret    = keccak256(ephemeral-key || aes-secret)
//!
//! Notes:
//! - All inputs and outputs are fixed 32-byte values (Voltaire Bytes32).
//! - This unit performs no allocation and relies solely on Voltaire crypto.
//! - The order of nonces is recipient first, then initiator, matching the spec.

const std = @import("std");
const primitives = @import("primitives");
const crypto = @import("crypto");

const Bytes32 = primitives.Bytes32.Bytes32;

/// Bundle of RLPx session secrets derived from ephemeral shared key and nonces.
pub const Secrets = struct {
    /// shared-secret per RLPx spec (32 bytes)
    shared: Bytes32,
    /// aes-secret for AES-CTR frame/header encryption (first 16 bytes used by AES-128)
    aes: Bytes32,
    /// mac-secret for keccak-based MAC state initialization
    mac: Bytes32,
};

/// Derive RLPx handshake secrets.
///
/// Inputs:
/// - `ephemeral_key`   — 32-byte ECDH result (Px) from ephemeral key agreement
/// - `initiator_nonce` — 32-byte nonce generated by the initiator (from auth)
/// - `recipient_nonce` — 32-byte nonce generated by the recipient (from ack)
///
/// Returns:
/// - `Secrets` with `shared`, `aes`, and `mac` fields populated per spec
pub fn deriveSecrets(
    ephemeral_key: Bytes32,
    initiator_nonce: Bytes32,
    recipient_nonce: Bytes32,
) Secrets {
    // inner = keccak256(recipient-nonce || initiator-nonce)
    var nonce_cat: [64]u8 = undefined;
    @memcpy(nonce_cat[0..32], &recipient_nonce);
    @memcpy(nonce_cat[32..64], &initiator_nonce);
    const inner: Bytes32 = crypto.Hash.keccak256(&nonce_cat);

    // shared-secret = keccak256(ephemeral-key || inner)
    var eph_cat_inner: [64]u8 = undefined;
    @memcpy(eph_cat_inner[0..32], &ephemeral_key);
    @memcpy(eph_cat_inner[32..64], &inner);
    const shared: Bytes32 = crypto.Hash.keccak256(&eph_cat_inner);

    // aes-secret = keccak256(ephemeral-key || shared-secret)
    var eph_cat_shared: [64]u8 = undefined;
    @memcpy(eph_cat_shared[0..32], &ephemeral_key);
    @memcpy(eph_cat_shared[32..64], &shared);
    const aes: Bytes32 = crypto.Hash.keccak256(&eph_cat_shared);

    // mac-secret = keccak256(ephemeral-key || aes-secret)
    var eph_cat_aes: [64]u8 = undefined;
    @memcpy(eph_cat_aes[0..32], &ephemeral_key);
    @memcpy(eph_cat_aes[32..64], &aes);
    const mac: Bytes32 = crypto.Hash.keccak256(&eph_cat_aes);

    return .{ .shared = shared, .aes = aes, .mac = mac };
}

test "deriveSecrets: zero vectors match spec composition" {
    const zero32: Bytes32 = [_]u8{0} ** 32;

    // Manual spec composition
    var nonce_cat: [64]u8 = undefined;
    @memcpy(nonce_cat[0..32], &zero32);
    @memcpy(nonce_cat[32..64], &zero32);
    const inner = crypto.Hash.keccak256(&nonce_cat);

    var eph_cat_inner: [64]u8 = undefined;
    @memcpy(eph_cat_inner[0..32], &zero32);
    @memcpy(eph_cat_inner[32..64], &inner);
    const shared = crypto.Hash.keccak256(&eph_cat_inner);

    var eph_cat_shared: [64]u8 = undefined;
    @memcpy(eph_cat_shared[0..32], &zero32);
    @memcpy(eph_cat_shared[32..64], &shared);
    const aes = crypto.Hash.keccak256(&eph_cat_shared);

    var eph_cat_aes: [64]u8 = undefined;
    @memcpy(eph_cat_aes[0..32], &zero32);
    @memcpy(eph_cat_aes[32..64], &aes);
    const mac = crypto.Hash.keccak256(&eph_cat_aes);

    const got = deriveSecrets(zero32, zero32, zero32);
    try std.testing.expectEqualSlices(u8, &shared, &got.shared);
    try std.testing.expectEqualSlices(u8, &aes, &got.aes);
    try std.testing.expectEqualSlices(u8, &mac, &got.mac);
}

test "deriveSecrets: input variation changes outputs" {
    const z: Bytes32 = [_]u8{0} ** 32;
    var ones: Bytes32 = z;
    @memset(&ones, 0x01);
    var twos: Bytes32 = z;
    @memset(&twos, 0x02);

    const base = deriveSecrets(z, z, z);
    const ch_e = deriveSecrets(ones, z, z);
    const ch_i = deriveSecrets(z, ones, z);
    const ch_r = deriveSecrets(z, z, ones);

    try std.testing.expect(!std.mem.eql(u8, &base.shared, &ch_e.shared));
    try std.testing.expect(!std.mem.eql(u8, &base.aes, &ch_i.aes));
    try std.testing.expect(!std.mem.eql(u8, &base.mac, &ch_r.mac));

    // Symmetry on swapping nonces is not expected; order is recipient || initiator
    const swap = deriveSecrets(z, twos, ones);
    const noswap = deriveSecrets(z, ones, twos);
    try std.testing.expect(!std.mem.eql(u8, &swap.shared, &noswap.shared));
}
